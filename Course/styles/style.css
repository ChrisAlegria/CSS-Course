/* CSS: Es piel, ropa y maquillaje. */
/* CamelCase: El camelCase es una convención de escritura que se utiliza en programación para nombrar variables, funciones, clases, etc. Se escribe en minúsculas y cada palabra adicional comienza con mayúscula. Por ejemplo, "miVariable", "miFuncion", "miClasePersonalizada". */
/* Comentario y comentario multilinea: Texto o codigo que solamente el desarrollador puede ver, ademas estos no tendran ningun efecto en lo que visualiza el usuario, por lo que de manera global y en cualquier lenguaje se puede generar un comentarios con Ctrl + }. */
/* ";": El ";" indica unicamente el final de una declaración, si no se usa, el lenguaje interpretará que la declaración continúa. */
/* Hexadecimal: Es un codigo de 6 letras y numeros que se utilizan para representar colores. */
/* RGB: Es un modelo de color que se basa en la mezcla de los colores rojo, verde y azul, los cuales se combinan en diferentes proporciones para crear una amplia gama de colores. A diferencia de la mezcla de colores en pinturas o tintas, donde los colores se oscurecen al combinarse, en RGB los colores se iluminan más al mezclarse. Este modelo fue diseñado para pantallas y dispositivos digitales, ya que funciona mediante la emisión de luz, donde el color blanco se obtiene combinando los tres colores al máximo nivel y el negro se obtiene con la ausencia de luz. */ 
/* HSL: El modelo de color HSL (Hue, Saturation, Lightness) se basa en tres componentes: tonalidad, saturación y luminosidad, que se combinan en diferentes proporciones para generar una amplia gama de colores. A diferencia del modelo RGB, que se basa en la mezcla de colores primarios, HSL se enfoca en cómo percibimos los colores, lo que lo hace más intuitivo y fácil de usar. En HSL, la tonalidad (Hue) representa el color básico, la saturación (Saturation) define la intensidad o pureza del color, y la luminosidad (Lightness) indica qué tan claro o oscuro es el color. Este modelo es útil para diseñar colores de manera más visual y cercana a cómo los humanos percibimos las variaciones de color. */  
/* Funciones transparencia de colores: La transparencia en los colores permite que un color no sea completamente sólido, sino que se mezcle con el fondo o con otros colores. Esto significa que, si un elemento con color transparente se coloca encima de otro color, ambos se combinarán visualmente, haciendo que el elemento transparente se vea como si mezcláramos su color con el del fondo. Además, un elemento con transparencia también deja ver parcialmente los elementos que están detrás de él. Por ejemplo, si colocas un cuadro rojo semitransparente sobre una imagen de fondo, el cuadro se verá rojo pero permitirá ver la imagen detrás de él. */

/*^CSS*/
/* ? Propiedades de cualquier declaración CSS:
? {}: Toda declaración en CSS, fuera de los estilos directos en etiquetas mediante la propiedad "style", debe ir acompañada de llaves después del selector. Estas llaves permiten declarar los estilos dentro de ellas y actúan como delimitadores, indicando hasta dónde se aplican los estilos a un elemento, clase, etc. 
? ":": Se usan los ":" en la propiedad de la declaracion para separar la propiedad de su valor. Por ejemplo, "color: red;". 
? ";": Se usan los ";" al final de cada declaración para indicar que la declaración ha finalizado. Por ejemplo, "color: red;". */

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Tipos de declaraciones CSS /*
/* ~Declaración de estilos: En CSS, los estilos se pueden declarar de diferentes maneras, dependiendo de cómo se desee aplicar el estilo a los elementos HTML. Existen tres formas principales de declarar estilos: mediante una hoja CSS externa, mediante una etiqueta <style> dentro del HTML y mediante la propiedad "style" directamente en las etiquetas HTML. Cada método tiene sus propias características y ventajas, y se puede elegir el que mejor se adapte a las necesidades del proyecto. */
/* Todo - Declaración de estilos mediante una hoja CSS o etiqueta <style>: Los estilos pueden declararse mediante una hoja CSS externa o directamente dentro de la etiqueta <style> en el archivo HTML. En el caso de la hoja CSS, se vincula al HTML mediante un enlace <link>, permitiendo que el HTML lea y aplique todos los estilos definidos en ella. Por otro lado, la etiqueta <style> funciona de manera similar, pero los estilos se colocan directamente dentro del archivo HTML entre las etiquetas <style> y </style>, sin necesidad de archivo externo. */
/* &Estructura de estilos en hoja CSS o etiqueta <style>. */
/* ?Propiedades:  
? Selector: Es el elemento o clase al que se le aplicará el estilo. Por ejemplo, si usas "p", seleccionas todos los párrafos para aplicarles el estilo. Si usas una clase como ".mi-clase", solo los elementos con esa clase recibirán el estilo.
? Propiedad: Es la característica que quieres cambiar en un elemento. Por ejemplo, "color" te permite cambiar el color de algo, y "font-size" te permite cambiar el tamaño del texto. Cada propiedad controla un aspecto diferente del elemento. 
? Valor: Es lo que asignas a una propiedad para definir cómo se comporta. Por ejemplo para "color", usas un valor como "red" para indicar un color, para "font-size", usas un valor como "10px" para indicar el tamaño. Cada propiedad requiere un tipo específico de valor según su función. */ 
.estructura{ /**Selector.**/       
    color: /**Propiedad.**/
    red; /**Valor de la propiedad**/
}

/* Todo - Declaración de estilos en etiqueta HTML mediante la propiedad "style":  Los estilos declarados con la propiedad style="" se aplican exclusivamente a la etiqueta en la que se especifica la propiedad. Dentro de esta propiedad no es necesario usar un selector, ya que el estilo se asigna directamente al elemento en cuestión. */
/* &Estructura de estilos en etiquta HTML mediante la propiedad "style". */
/* ?Propiedades:  
? Propiedad: Es la parte dentro de una etiqueta HTML que se usa para declarar estilos directamente. Por ejemplo, en <p style="">, "style" es la propiedad que indica que dentro de las comillas se escribirán los estilos. 
? Propiedad: Es la característica que quieres cambiar en un elemento. Por ejemplo, "color" te permite cambiar el color de algo, y "font-size" te permite cambiar el tamaño del texto. Cada propiedad controla un aspecto diferente del elemento. 
? Valor: Es lo que asignas a una propiedad para definir cómo se comporta. Por ejemplo para "color", usas un valor como "red" para indicar un color, para "font-size", usas un valor como "10px" para indicar el tamaño. Cada propiedad requiere un tipo específico de valor según su función. *//*
style=" /**Atributo.*
color: /**Propiedad*
red;" /**Valor**/

/* Todo - Declaración: Una declaración es el conjunto de la estructura que incluye el "selector/atributo", la "propiedad" y el "valor de la propiedad**. En CSS, cada declaración se escribe entre llaves {}. */
.declaracion{ /**Selector.**/
color: red; /** Declaración: propiedad + valor **/
} /**Cierre de la declaración.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Selectores /*
/* ~Selectores: Los selectores son patrones que se utilizan para seleccionar los elementos HTML a los que se les aplicarán los estilos. Existen diferentes tipos de selectores, cada uno con su propia función y especificidad. Los selectores pueden ser de tipo elemento, clase, identificador, cuerpo, universal, combinados o múltiples. */
/* Todo - Selectores de elemento (nombreElemento{}): Los selectores de elemento se utilizan para aplicar estilos a todas las instancias de una etiqueta HTML específica. Esto significa que, cuando usas el nombre de una etiqueta, como "h1{}", los estilos dentro de ese selector afectarán a todos los elementos de ese tipo en la página. Por ejemplo, si escribes "h1 { color: red; }", todas las etiquetas <h1> en la página se pondrán rojas. */
h1{ /**Declaracion de selector por elemento, en este caso se declara la etiqueta <h1>.**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
} /**Cierre de la declaración de selector por elemento.**/

/* Todo - Selectores de clase (.nombreClase{}): Los selectores de clase se utilizan para aplicar estilos a un grupo específico de elementos que comparten la misma clase (la cual se establece en las etiquetas mediante la propiedad class=""). Esto significa que, cuando usas un punto seguido de un nombre de clase, como ".mi-clase{}", los estilos dentro de ese selector afectarán a todos los elementos que tengan esa clase en la página. Por ejemplo, si escribes ".mi-clase { font-size: 20px; }", todos los elementos con la clase "mi-clase" tendrán un tamaño de fuente de 20 píxeles, por lo que uno o varios elementos pueden tener la misma clase a los cuales se les aplicaran los mimos estilos. */
.mi-clase{ /**Declaracion de selector por clase, en este caso se declara la clase "mi-clase".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
}   /**Cierre de la declaración de selector por clase.**/

/* Todo - Selector de identificador (#nombreIdentificador): Los selectores de identificador se utilizan para aplicar estilos a un elemento específico que tenga un identificador único, el cual se establece en las etiquetas mediante la propiedad `id=""`. Esto significa que cuando usas un signo de almohadilla seguido de un nombre de identificador, como "#titulo{}", los estilos dentro de ese selector afectarán únicamente al elemento que tenga ese identificador en la página. Por ejemplo, si escribes "#titulo { color: blue; }", solo el elemento con el identificador "titulo" tendrá un color azul. Cabe destacar que, aunque CSS permite aplicar estilos a varios elementos con el mismo ID, esto no semanticamente recomendable, ya que los ID están diseñados para ser únicos e irrepetibles dentro de un documento HTML. */
#titulo{ /**Declaracion de selector por identificador, en este caso se declara el identificador "titulo".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
}   /**Cierre de la declaración de selector por identificador.**/

/* Todo - Selectores de cuerpo (body{}): Los selectores de cuerpo se utilizan para aplicar estilos al cuerpo base de la página, como el color de fondo, el margen del cuerpo, el tipo de fuente, el tamaño de fuente, entre otros. Esto significa que, cuando declaras un estilo en "body{}", todos los elementos dentro del cuerpo de la página heredarán esos estilos, a excepción de aquellos que tengan estilos específicos definidos. Es decir, este selector solo afecta el texto o contenido general del cuerpo, pero no las etiquetas que se encuentren dentro de él si tienen sus propios estilos. Por ejemplo, si escribes "body { background-color: lightgray; }", el fondo de toda la página será gris claro, pero si tienes un elemento `<h1>` con un color específico, ese color no cambiará. */
body{ /**Declaracion de selector por cuerpo, en este caso se declara el cuerpo de la página.**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
} /**Cierre de la declaración de selector por cuerpo.**/

/* Todo - Selectores universales (*{}): El selector universal "*" pese a no ser muy recomendado, se utiliza para aplicar estilos a todos los elementos dentro de la página, sin excepción. Esto incluye todo el contenido, como el texto, las imágenes, las etiquetas, etc. A diferencia del selector "body{}", que solo afecta el área del cuerpo de la página, el selector "*" aplica los estilos a todos los elementos, incluidos aquellos fuera del cuerpo (por ejemplo, elementos de encabezado o barra de navegación). Sin embargo, si un elemento tiene estilos específicos definidos por otro selector, estos prevalecerán sobre los estilos del selector universal. Por ejemplo, si escribes "* { margin: 0; padding: 0; }", todos los elementos de la página perderán márgenes y rellenos, sin importar qué tipo de contenido sean. */
*{  /**Declaracion de selector universal, en este caso se declara el selector universal "*".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
}   /**Cierre de la declaración de selector universal.**/

/* Todo - Selectores combinados ("nombreElemento.nombreClase{}", "nombreElemento#nombreIdentificador{}", ".mi-clase.mi-clase2{}", ".mi-clase#miIdentificador{}"): Los selectores combinados se usan para aplicar estilos a elementos específicos que tienen una combinación de etiquetas, clases e identificadores. Esto significa que, cuando usas un selector que combina un tipo de elemento, una clase o un ID, como "h1.mi-clase{}", los estilos dentro de ese selector afectarán solo a los elementos que cumplas con ambas especificaciones. Por ejemplo, si escribes "h1.mi-clase { color: blue; }", solo los elementos `<h1>` con la clase "mi-clase" tendrán el color azul. De la misma manera, puedes combinar clases, identificadores o elementos para hacer más específicos los estilos aplicados. */
h2.mi-clase{ /**Declaracion de selector combinado, en este caso se declara la etiqueta <h2> con la clase "mi-clase".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
}   /**Cierre de la declaración de selector combinado.**/
h2#miIdentificador{ /**Declaracion de selector combinado, en este caso se declara la etiqueta <h2> con el identificador "miIdentificador".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
}   /**Cierre de la declaración de selector combinado.**/
.mi-clase.mi-clase2{ /**Declaracion de selector combinado, en este caso se declara la clase "mi-clase" con la clase "mi-clase2".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
}   /**Cierre de la declaración de selector combinado.**/
.mi-clase#miIdentificador{ /**Declaracion de selector combinado, en este caso se declara la clase "mi-clase" con el identificador "miIdentificador".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
}   /**Cierre de la declaración de selector combinado.**/

/* Todo - Selector multiple (h1, h2, h3{}): Los selectores múltiples se utilizan para aplicar estilos a varios elementos al mismo tiempo, ya sea del mismo tipo o de diferentes tipos de selectores, como lo son: clase, elemento, identificador y cuerpo. Esto significa que, cuando declaras un estilo en "h1, h2, h3{}", todos los elementos `<h1>`, `<h2>` y `<h3>` en la página heredarán esos estilos. Por ejemplo, si escribes "h1, .mi-clase, #titulo { color: blue; }", todos los elementos <h1>, los elemntos con la clase "mi-clase" y el elemento con el identificador "titulo" tendrán un color de texto azul. */
h1, h2, h3{ /**Declaracion de selector multiple, en este caso se declaran los elementos <h1>, <h2> y <h3>.**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
} /**Cierre de la declaración de selector multiple.**/

h1,.mi-clase{ /**Declaracion de selector multiple, en este caso se declaran los elementos <h1> y la clase "mi-clase".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
} /**Cierre de la declaración de selector multiple.**/

h1,#titulo{ /**Declaracion de selector multiple, en este caso se declaran los elementos <h1> y el identificador "titulo".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
} /**Cierre de la declaración de selector multiple.**/

.mi-clase,#titulo{ /**Declaracion de selector multiple, en este caso se declaran la clase "mi-clase" y el identificador "titulo".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
} /**Cierre de la declaración de selector multiple.**/

h1,.mi-clase,#titulo{ /**Declaracion de selector multiple, en este caso se declaran los elementos <h1>, la clase "mi-clase" y el identificador "titulo".**/
    /**Aqui se especifican las propiedades y sus valores para asigar estilos.**/
} /**Cierre de la declaración de selector multiple.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Prioridad de Aplicación de Estilos Segun el Selector /*
/* Todo - Prioridad de aplicación de estilos: La prioridad de aplicación de estilos en CSS depende de la especificidad de los selectores. Esto significa que cada selector tiene un nivel de importancia al momento de aplicar estilos. Aunque varios selectores puedan aplicar estilos a un mismo elemento, algunos tendrán mayor relevancia que otros. En caso de que varios selectores afecten la misma propiedad de un elemento, el selector con mayor especificidad sobrescribirá los estilos definidos por los selectores con menor prioridad. */
/* &Prioridad baja */
* { /**Selector universal.**/
    /** Las propiedades especificadas aqui aplicaran a todos los elementos de la página.**/
} /**Cierre de selector universal.**/

/* &Prioridad semi baja */
body { /**Selector de cuerpo.**/
    /**Las propiedades especificadas aqui aplicaran al cuerpo de la página.**/
} /**Cierre de selector de cuerpo.**/

/* &Prioridad media */
h1 { /**Selector de elemento.**/
    /**Las propiedades especificadas aqui aplicaran solo a los elementos <h1>.**/
} /**Cierre de selector de elemento.**/

/* &Prioridad media-alta */
.mi-clase { /**Selector de clase.**/
    /**Las propiedades especificadas aqui aplicaran solo a los elementos con la clase "mi-clase".**/
} /**Cierre de selector de clase.**/

/* &Prioridad alta */
h1.mi-clase { /**Selector combinado.**/
    /**Las propiedades especificadas aqui aplicaran a los elementos <h1> que tengan la clase "mi-clase".**/
} /**Cierre de selector combinado.**/

/* &Prioridad muy alta */
#titulo { /**Selector de identificador.**/
    /**Las propiedades especificadas aqui aplicaran solo al elemento con el ID "titulo".**/
} /**Cierre de selector de identificador.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Colores */
/* ~Los colores en CSS se pueden especificar de varias formas, como por nombre, hexadecimal, RGB, HSL, entre otros. Cada forma tiene sus propias características y ventajas, ademas estos pueden ser usados en propiedades como color de texto, color de fondo, color de borde, entre otros. */
/* Todo - Colores por nombre: Los colores por nombre son una forma de especificar un color solido como valor de una propiedad utilizando su nombre en inglés. Existen 147 colores predefinidos que pueden ser utilizados por nombre. Por ejemplo, si se desea que un texto sea rojo, se puede especificar el color "red" en la propiedad "color", pero por el momento solo existe un conjunto limitado de colores que se pueden especificar por nombre. */
.color-por-nombre{ /**Se declara un selector por clase llamado "color-por-nombre".**/
    background-color: crimson; /**Se asigna una propiedad de color de fondo con el valor por nombre "crimson".**/
} /**Cierre de la declaración de selector por clase.**/

/* Todo - Colores por hexadecimal: Los colores por hexadecimal son una forma de especificar un color como valor de una propiedad utilizandoun código hexadecimal. Cada color tiene un código hexadecimal único que se compone de una combinación de seis caracteres alfanuméricos o en su caso si se selecciona un color hexadecimal con transparencia, se compone de ocho caracteres alfanuméricos. Por ejemplo, si se desea que un texto sea rojo, se puede especificar el color "#ff0000" en la propiedad "color", pero en caso de un color con transparencia se puede especificar el color "#ff0000ff". */
/* ?Propiedades:  
? #: Propiedad que define que el color a asignar en el valor de la propiedad será declarado mediante hexadecimal. */
/* &Hexadecimal estandar */
.color-por-hexadecimal-estandar{ /**Se declara un selector por clase llamado "color-por-hexadecimal-estandar".**/
    background-color: #007bff; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#007bff".**/
} /**Cierre de la declaración de selector por clase.**/

/* &Hexadecimal con transparencia */
.color-por-hexadecimal-con-transparencia{ /**Se declara un selector por clase llamado "color-por-hexadecimal-con-transparencia".**/
    background-color: #fffb005e; /**Se asigna una propiedad de color de fondo con el valor hexadecimal con transparencia "#fffb005e".**/
} /**Cierre de la declaración de selector por clase.**/

/* Todo - Colores por RGB: Los colores por RGB son una forma de especificar un color como valor de una propiedad utilizando el modelo de color RGB. Este modelo se basa en la mezcla de los colores rojo, verde y azul en diferentes proporciones para crear una amplia gama de colores. Cada color se define con un valor entre 0 y 255 para cada uno de los tres colores primarios, por lo que para la seleccion de colores solidos por RGB se utiliza la función rgb(). En caso de seleccionar un color RGB con transparencia, se utiliza la función rgba(). Por ejemplo, si se desea un color solido en un texto se puede especificar el color "rgb(255, 0, 0)" en la propiedad "color", pero en caso de un color con transparencia se puede especificar el color "rgba(255, 0, 0, 0.5)". */
/* &RGB estandar */
/* ?Propiedades:   
? rgb(): Función que permite especificar un color mediante los valores de rojo, verde y azul. Cada valor debe estar entre 0 y 255. */
.color-por-rgb-estandar{ /**Se declara un selector por clase llamado "color-por-rgb-estandar".**/
    background-color: rgb(107, 247, 0); /**Se asigna una propiedad de color de fondo con el valor RGB "rgb(107, 247, 0)".**/
} /**Cierre de la declaración de selector por clase.**/

/* &RGB con transparencia */
/* ?Propiedades:
? rgba(): Función que permite especificar un color mediante los valores de rojo, verde, azul y un valor de transparencia. Cada valor de color debe estar entre 0 y 255,  mas el valor de transparencia "alpha" el cual debe estar entre 0 y 1. */
.color-por-rgb-con-transparencia{ /**Se declara un selector por clase llamado "color-por-rgb-con-transparencia".**/
    background-color: rgba(125, 0, 127, 0.324); /**Se asigna una propiedad de color de fondo con el valor RGB con transparencia "rgba(125, 0, 127, 0.324)".**/
} /**Cierre de la declaración de selector por clase.**/

/* Todo - Colores por HSL: Los colores por HSL son una forma de especificar un color como valor de una propiedad utilizando el modelo de color HSL. Este modelo se basa en tres componentes la tonalidad (Hue) que representa el color básico, la saturación (Saturation) define la intensidad o pureza del color, y la luminosidad (Lightness) indica qué tan claro o oscuro es el color. Cada color se define con un valor entre 0 y 360 para la tonalidad, entre 0% y 100% para la saturación y la luminosidad, por lo que para la seleccion de colores solidos por RGB se utiliza la función hsl(). En caso de seleccionar un color HSL con transparencia, se utiliza la función hsla(). Por ejemplo, si se desea un color solido en un texto se puede especificar el color "hsl(0, 100%, 50%)" en la propiedad "color", pero en caso de un color con transparencia se puede especificar el color "hsla(0, 100%, 50%, 0.5)". */
/* &HSL estandar */
/* ?Propiedades:
? hsl(): Función que permite especificar un color mediante los valores de tonalidad, saturación y luminosidad. La tonalidad se mide en grados (0 a 360), mientras que la saturación y la luminosidad se miden en porcentajes (0% a 100%). */
.color-por-hsl-estandar{ /**Se declara un selector por clase llamado "color-por-hsl-estandar".**/
    background-color: hsl(173, 100%, 50%); /**Se asigna una propiedad de color de fondo con el valor HSL "hsl(173, 100%, 50%)".**/
} /**Cierre de la declaración de selector por clase.**/

/* &HSL con transparencia */
/* ?Propiedades:
? hsla(): Función que permite especificar un color mediante los valores de tonalidad, saturación, luminosidad y un valor de transparencia. La tonalidad se mide en grados (0 a 360), mientras que la saturación y la luminosidad se miden en porcentajes (0% a 100%), mas el valor de transparencia "alpha" el cual debe estar entre 0 y 1. */
.color-por-hsl-con-transparencia{ /**Se declara un selector por clase llamado "color-por-hsl-con-transparencia".**/
    background-color: hsla(0, 100%, 50%, 0.219); /**Se asigna una propiedad de color de fondo con el valor HSL con transparencia "hsla(0, 100%, 50%, 0.219)".**/
} /**Cierre de la declaración de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Unidades de medida */
/* ~Las unidades de medida son valores que se utilizan para definir tamaños, distancias, espacios, entre otros aspectos en CSS. Estas unidades permiten especificar dimensiones de manera precisa y relativa, adaptándose a las necesidades de diseño de la página web. */ 
/* &No Relativas */
/* &Las unidades de medida no relativas son valores fijos que se utilizan para definir tamaños, distancias, espacios, entre otros aspectos en CSS. Estas unidades permiten especificar dimensiones de manera precisa y constante, sin importar el tamaño de la pantalla o del contenido. Por lo que estas unidades no se ajustan automáticamente a los cambios en el tamaño de la pantalla o del contenido. */
/* Todo - Unidad de medida no relativa de pixeles (px): La unidad de medida en pixeles (px) es una unidad fija que se utiliza para especificar tamaños, distancias, espacios, entre otros aspectos en CSS. Por lo que un pixel es la unidad más pequeña de medida en una pantalla, y se utiliza para definir tamaños precisos y constantes. Por ejemplo, si se asigna un ancho de 100px a un elemento, este tendrá un ancho de 100 píxeles, independientemente del tamaño de la pantalla o del contenido. */
.unidad-de-medida-no-relativa-pixeles{ /**Se declara un selector por clase llamado "unidad-de-medida-no-relativa-pixeles".**/
    width: 700px; /**Se asigna una propiedad de ancho con el valor de medida en pixeles "100px".**/
    background-color: rgb(155, 255, 118); /**Se asigna una propiedad de color de fondo con el valor RGB "rgb(118, 173, 255)".**/
} /**Cierre de la declaración de selector por clase.**/

/* Todo - Unidad de medida no relativa de altura de tamaño de fuente de letra (ex): La unidad de medida "ex" se utiliza para especificar un tamaño o una posición en relación con la altura de letra "x" segun la fuente del elemento. Esto significa que, si se asigna un valor de 2ex a un ancho, altura o margen, el elemento se ajustará al doble de la altura de letra "x" de la fuente del elemento. Por ejemplo, si la altura de letra "x" es de 16px, un elemento con un ancho de 2ex tendrá un ancho de 32px. */
.unidad-de-medida-no-relativa-ex{ /**Se declara un selector por clase llamado "unidad-de-medida-ex".**/
    font-size: 16px; /**Se asigna una propiedad de tamaño de fuente con el valor de medida en pixeles "16px".**/
    height: 2ex; /**Se asigna una propiedad de margen con el valor de medida no relativa "2ex".**/
    background-color: rgb(155, 255, 118); /**Se asigna una propiedad de color de fondo con el valor RGB "rgb(118, 173, 255)".**/
} /**Cierre de la declaración de selector por clase.**/

/* &Relativas */
/* &Las unidades de medida relativas son valores que se basan en el tamaño de otros elementos, como el tamaño de la fuente, el ancho del contenedor o el tamaño de la ventana del navegador. Estas unidades permiten crear diseños flexibles y adaptables, ya que se ajustan automáticamente a los cambios en el tamaño de la pantalla o del contenido. */
/* Todo - Unidad de medida relativa a el elemento padre (%): La unidad de medida porcentual (%) se utiliza para especificar un tamaño o una posición en relación con el tamaño del elemento padre. Esto significa que, si se asigna un valor de 50% a un ancho, altura o margen, el elemento se ajustará al 50% del tamaño del elemento padre. Por ejemplo, si el elemento padre tiene un ancho de 100px, un elemento hijo con un ancho de 50% tendrá un ancho de 50px. Por ejemplo si un div esta dentro de un section y se establece un ancho de 50% al div, este tendra un ancho de la mitad del section. */
.unidad-de-medida-relativa-porcentual{ /**Se declara un selector por clase llamado "unidad-de-medida-porcentual".**/
    width: 50%; /**Se asigna una propiedad de ancho con el valor de medida porcentual "50%".**/
    background-color: rgb(155, 195, 255); /**Se asigna una propiedad de color de fondo con el valor RGB "rgb(155, 195, 255)".**/
} /**Cierre de la declaración de selector por clase.**/

/* Todo - Unidad de medida relativa al font size del elemento (em): La unidad de medida "em" se utiliza para especificar un tamaño o una posición en relación con el tamaño de la fuente del elemento. Esto significa que, si se asigna un valor de 2em a un ancho, altura o margen, el elemento se ajustará al doble del tamaño de la fuente del elemento. Por ejemplo, si el tamaño de la fuente es de 16px, un elemento con un ancho de 2em tendrá un ancho de 32px. Por ejemplo si se establece un tamaño de fuente de 16px a un parrafo y se establece un margen de 2em, este tendra un margen de 32px. */
.unidad-de-medida-relativa-em{ /**Se declara un selector por clase llamado "unidad-de-medida-em".**/
    font-size: 15px; /**Se asigna una propiedad de tamaño de fuente con el valor de medida en pixeles "16px".**/
    height: 4em; /**Se asigna una propiedad de margen con el valor de medida relativa "2em".**/
    background-color: rgb(155, 195, 255); /**Se asigna una propiedad de color de fondo con el valor RGB "rgb(155, 195, 255)".**/
} /**Cierre de la declaración de selector por clase.**/

/* Todo - Unidad de medida relativa al font size del elemento raiz (rem): La unidad de medida "rem" se utiliza para especificar un tamaño o una posición en relación con el tamaño de la fuente del elemento raíz (html). Esto significa que, si se asigna un valor de 2rem a un ancho, altura o margen, el elemento se ajustará al doble del tamaño de la fuente del elemento raíz. Por ejemplo, si el tamaño de la fuente del elemento raíz es de 16px, un elemento con un ancho de 2rem tendrá un ancho de 32px. Por ejemplo si se establece un tamaño de fuente de 16px al elemento raiz y se establece un margen de 2rem a un parrafo, este tendra un margen de 32px. */
.unidad-de-medida-relativa-rem{
    height: 3rem; /**Se asigna una propiedad de margen con el valor de medida relativa "2rem".**/
    background-color: rgb(155, 195, 255); /**Se asigna una propiedad de color de fondo con el valor RGB "rgb(155, 195, 255)".**/
}

/* Todo - Unidad de medida relativa al 1% de ancho del viewport (vw): La unidad de medida "vw" se utiliza para especificar un tamaño o una posición en relación con el ancho del viewport (ventana del navegador). Esto significa que, si se asigna un valor de 2vw a un ancho, altura o margen, el elemento se ajustará al 2% del ancho de la ventana del navegador. Por ejemplo, si el ancho de la ventana del navegador es de 1000px, un elemento con un ancho de 2vw tendrá un ancho de 20px. Por ejemplo si se establece un ancho de 50vw a un div, este tendra un ancho de la mitad del ancho de la ventana del navegador. */
.unidad-de-medida-relativa-vw{ /**Se declara un selector por clase llamado "unidad-de-medida-vw".**/
    width: 30vw; /**Se asigna una propiedad de ancho con el valor de medida relativa "50vw".**/
    background-color: rgb(155, 195, 255); /**Se asigna una propiedad de color de fondo con el valor RGB "rgb(155, 195, 255)".**/
} /**Cierre de la declaración de selector por clase.**/

/* Todo - Unidad de medida relativa al 1% de alto del viewport (vh): La unidad de medida "vh" se utiliza para especificar un tamaño o una posición en relación con el alto del viewport (ventana del navegador). Esto significa que, si se asigna un valor de 2vh a un ancho, altura o margen, el elemento se ajustará al 2% del alto de la ventana del navegador. Por ejemplo, si el alto de la ventana del navegador es de 500px, un elemento con un alto de 2vh tendrá un alto de 10px. Por ejemplo si se establece un alto de 50vh a un div, este tendra un alto de la mitad del alto de la ventana del navegador. */
.unidad-de-medida-relativa-vh{ /**Se declara un selector por clase llamado "unidad-de-medida-vh".**/
    height: 15vh; /**Se asigna una propiedad de margen con el valor de medida relativa "50vh".**/
    background-color: rgb(155, 195, 255); /**Se asigna una propiedad de color de fondo con el valor RGB "rgb(155, 195, 255)".**/
} /**Cierre de la declaración de selector por clase.**/

/* Todo - Unidad de medida relativa al 1% del lado mas grande del viewport (vmax): La unidad de medida "vmax" se utiliza para especificar un tamaño o una posición en relación con el lado más grande del viewport (ventana del navegador). Esto significa que, si se asigna un valor de 2vmax a un ancho, altura o margen, el elemento se ajustará al 2% del lado más grande de la ventana del navegador. Por ejemplo, si el lado más grande de la ventana del navegador es de 1000px, un elemento con un ancho de 2vmax tendrá un ancho de 20px. Por ejemplo si se establece un ancho de 50vmax a un div, este tendra un ancho de la mitad del lado más grande de la ventana del navegador. */
.unidad-de-medida-relativa-vmax{ /**Se declara un selector por clase llamado "unidad-de-medida-vmax".**/
    width: 20vmax; /**Se asigna una propiedad de ancho con el valor de medida relativa "50vmax".**/
    background-color: rgb(155, 195, 255); /**Se asigna una propiedad de color de fondo con el valor RGB "rgb(155, 195, 255)".**/
} /**Cierre de la declaración de selector por clase.**/

/* Todo - Unidad de medida relativa al 1% del lado mas pequeño del viewport (vmin): La unidad de medida "vmin" se utiliza para especificar un tamaño o una posición en relación con el lado más pequeño del viewport (ventana del navegador). Esto significa que, si se asigna un valor de 2vmin a un ancho, altura o margen, el elemento se ajustará al 2% del lado más pequeño de la ventana del navegador. Por ejemplo, si el lado más pequeño de la ventana del navegador es de 500px, un elemento con un ancho de 2vmin tendrá un ancho de 10px. Por ejemplo si se establece un ancho de 50vmin a un div, este tendra un ancho de la mitad del lado más pequeño de la ventana del navegador. */
.unidad-de-medida-relativa-vmin{ /**Se declara un selector por clase llamado "unidad-de-medida-vmin".**/
    width: 30vmin; /**Se asigna una propiedad de ancho con el valor de medida relativa "50vmin".**/
    background-color: rgb(155, 195, 255); /**Se asigna una propiedad de color de fondo con el valor RGB "rgb(155, 195, 255)".**/
} /**Cierre de la declaración de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Backgrounds */
/* ~El fondo de un elemento (background) en CSS se utiliza para personalizar el fondo de un elemento, como un contenedor, una sección o el cuerpo de la página web. El fondo puede ser un color sólido, un degradado de colores, una imagen, o una combinación de estos elementos. */
/* Todo - Background con solido/con transparencia (background-color{}): El color de fondo sólido o con transparencia se utiliza para cambiar el color de fondo de un elemento, como un contenedor, una sección o el cuerpo de la página web. Por lo que se puede especificar un color sólido o un color con transparencia para el fondo de un elemento, ya sea usando colores por nombre, hexadecimal, RGB, HSL, entre otros. */
.background-con-color-solido-transparente{ /**Se declara un selector por clase llamado "background-con-color-solido-transparente".**/
    background-color: orange; /**Se declara una propiedad de color de fondo con el color solido "orange".**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Background con colores degradados (background: linear-gradient()): Los colores degradados se utilizan para crear un efecto visual en el que un color se mezcla gradualmente con otro, podiendo crear transiciónes suaves o abruptas entre dos o más colores. Para crear un degradado de colores, se utiliza la propiedad "background" con la función "linear-gradient()", la cual permite especificar la dirección hacia donde ira el degradado y los colores que se mezclaran, podiendo usar colores por nombre, hexadecimal, RGB, HSL, entre otros. */
/* ?Propiedades:
? linear-gradient(deg, color1, color2, ...): Función que permite crear un degradado de colores en una dirección específica. Se pueden especificar uno o más colores para crear la transición entre ellos. Para definir el degradado se debe especificar la dirección del degradado, usando un ángulo en grados (0deg a 360deg), seguido de los colores que formarán la transición y las posiciones en las que se encontrarán. La posición de cada color se determina en porcentaje, el cual representa el espacio del fondo en base a la dirección del degradado. Por ejemplo, si usas 60% para el primer color, significa que a partir del 60% del fondo del elemento comenzará ese color. Si el siguiente color tiene 62%, el 2% restante (de la diferencia entre 60% y 62%) se utilizará para aplicar el degradado entre los dos colores. Este proceso permite crear transiciones suaves entre los colores a medida que se avanza en el fondo del elemento. */
.background-con-colores-degradados{ /**Se declara un selector por clase llamado "background-con-colores-degradados".**/
    background: linear-gradient(270deg, GreenYellow 0%, rgb(0, 132, 255) 60%, #f048ff 100%); /**Se declara una propiedad de color de fondo con un degradado de colores, usando un color por nombre "green", un color en hexadecimal "#0084ff" y un color RGB "rgb(240, 72, 255)".**/;
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Background size (background-size{}): La propiedad `background-size{}` se utiliza para controlar el tamaño de una imagen de fondo en un elemento HTML. Esta propiedad permite especificar el tamaño exacto de la imagen de fondo, ya sea en píxeles, porcentajes o usando palabras clave como "cover" o "contain". La propiedad `background-size{}` es especialmente útil cuando se trabaja con imágenes de fondo que no tienen el mismo tamaño que el elemento al que están aplicadas. *, para el caso de cover, la imagen de fondo se ajustará para cubrir todo el espacio del elemento sin ocacionar que esto afecte al aspecto de la imagen, lo que puede resultar en un recorte de la imagen. Mientras que en el caso de contain este es el que viene por defecto, la imagen de fondo se ajustará para que quepa dentro del elemento manteniendo su proporción original, lo que ocaciona que para cubrir todo el espacio del elemento, la imagen pueda repetirse. De igual manera se puede especificar un tamaño exacto en píxeles, porcentajes o cualquier otra unidad de medida. */
.background-size{ /**Se declara un selector por clase llamado "background-size".**/
    background-image: url('../assets/images/backgrounds/Background_Image_1.jpg'); /**Se declara una propiedad de imagen de fondo con la imagen "kimetsu.jpeg".**/
    background-size: cover; /**Se declara una propiedad de tamaño de imagen de fondo con el valor "cover", ocacionando que la imagen cubra todo el espacio del elemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Background con imágenes (background-image{}): Las imágenes de fondo se utilizan para agregar una imagen a un elemento HTML, como un contenedor, una sección o el cuerpo de la página web. Para agregar una imagen de fondo, se usa la propiedad `background-image{}` junto con la función `url()`, donde se coloca la dirección de la imagen que se quiere utilizar. Por defecto, la imagen se insertará con su tamaño original. Si la imagen es muy pequeña para cubrir el ancho o alto del elemento esta se colocara en la esquina superior izquierda del elementp y ademas se repetirá automáticamente para llenar el espacio disponible. De la misma manera, si la imagen es más grande pero no cubre toda la altura del elemento, también se repetirá. */
.background-con-imagen{ /**Se declara un selector por clase llamado "background-con-imagen".**/
    background-image: url('../assets/images/backgrounds/Background_Image_2.jpg'); /**Se declara una propiedad de imagen de fondo con la imagen "kimetsu.jpeg".**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Background con modificacion de repeticion de imagenes (background-repeat{}): La propiedad `background-repeat{}` se utiliza para controlar la repetición de una imagen de fondo en un elemento HTML. Por defecto, las imágenes de fondo se repiten tanto horizontal como verticalmente para cubrir todo el espacio disponible. Sin embargo, esta propiedad permite modificar este comportamiento y definir si la imagen se repite solo en una dirección, en ambas direcciones o no se repite en absoluto. Para definir que solo se repita en X o Y, se puede usar los valores "repeat-x" o "repeat-y", respectivamente. En caso de que no se quiera que la imagen se repita, se puede usar el valor "no-repeat". */
.background-con-modificacion-de-repeticion-de-imagen{ /**Se declara un selector por clase llamado "background-con-modificacion-de-repeticion-de-imagenes".**/
    background-image: url('../assets/images/backgrounds/Background_Image_3.jpg'); /**Se declara una propiedad de imagen de fondo con la imagen "Sunset.jpg".**/
    background-repeat: no-repeat;  /**Se declara una propiedad de repeticion de imagen de fondo con el valor "no-repeat", ocacionando que la imagen no se repita.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Posición de fondo (background-position{}): La propiedad `background-position{}` se utiliza para controlar la posición del fondo en un elemento. Aunque se usa comúnmente con `background-image`, también puede aplicarse a cualquier tipo de fondo, como colores sólidos, degradados, imágenes, entre otros, los cuales no abarquen todo el espacio del elemento. Esta propiedad permite especificar la ubicación exacta donde se mostrará el fondo dentro del elemento HTML. Se puede definir la posición usando valores como arriba (top), abajo (bottom), izquierda (left), derecha (right), centro (center), o en valores personalizados como porcentajes o píxeles. */
.background-con-posicion-de-fondo{ /**Se declara un selector por clase llamado "background-con-posicion-de-imagen".**/
    background-image: url('../assets/images/backgrounds/Background_Image_4.jpg'); /**Se declara una propiedad de imagen de fondo con la imagen "landscape.jpg".**/
    background-color: rgb(205, 218, 239);  /**Se declara una propiedad de color de fondo con el color solido por rgb.**/
    background-repeat: no-repeat;  /**Se declara una propiedad de repeticion de imagen de fondo con el valor "no-repeat", ocacionando que la imagen no se repita.**/
    background-position: center; /**Se declara una propiedad de posicion de imagen de fondo con el valor "center", ocacionando que la imagen se posicione en el centro del elemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Fondo con seguimiento (background-attachment{}): La propiedad `background-attachment{}` se utiliza para controlar el comportamiento de un fondo en relación al desplazamiento del contenido de un elemento. Por defecto, el fondo se desplaza junto con el contenido, lo que significa que si el contenido se mueve, el fondo también lo hará. Sin embargo, con esta propiedad puedes modificar ese comportamiento y hacer que el fondo permanezca fijo en su lugar, independientemente de cómo se desplace el contenido. Para mantener el fondo fijo, se utiliza el valor "fixed" el cual mantiene el fondo fijo en relación con la página web, no al elemento en sí. También se puede usar el valor "scroll" (por defecto), que hace que el fondo se desplace con el contenido. */
.background-con-seguimiento-de-fondo{ /**Se declara un selector por clase llamado "background-con-seguimiento-de-fondo".**/
    background-image: url('../assets/images/backgrounds/Background_Image_5.jpg'); /**Se declara una propiedad de imagen de fondo con la imagen "Forest.jpg".**/
    background-repeat: no-repeat;  /**Se declara una propiedad de repeticion de imagen de fondo con el valor "no-repeat", ocacionando que la imagen no se repita.**/
    background-position: center; /**Se declara una propiedad de posicion de imagen de fondo con el valor "center", ocacionando que la imagen se posicione en el centro del elemento.**/
    background-attachment: fixed; /**Se declara una propiedad de seguimiento de imagen de fondo con el valor "fixed", ocacionando que la imagen se mantenga fija en su lugar.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Shorthand de background (background{}): Es una propiedad que engloba todas las propiedades de fondo en una sola declaración. Esto permite definir el color, la imagen, la repetición, la posición y el seguimiento del fondo en un solo lugar en este orden (color, image, repeat, position, attachment). Por lo que nos permite declarar todas estas propiedas sin usar propiedades separadas, lo que facilita la escritura y la lectura del código. Ademas no es necesario integrar todas las propiedades, ya que se pueden omitir algunas si no se desean aplicar. Por lo que la estructura de short-hand de background usando todas las propiedades podria ser background: #000000 url('imagen.jpg') no-repeat center fixed; Por lo que podemos ver que unicamente se usaron los valores de las propiedades que se desean aplicar. */
.background-con-shorthand-de-background{ /**Se declara un selector por clase llamado "background-con-shorthand-de-background".**/
    background: rgb(205, 218, 239) url('../assets/images/backgrounds/Background_Image_6.jpg') no-repeat center scroll; /**Se declara una propiedad de fondo con todas las propiedades en una sola declaración.**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Borders */
/* ~Los bordes en CSS son líneas que rodean los elementos HTML, como contenedores, secciones, imágenes, entre otros. Los bordes se utilizan para definir los límites de un elemento y para separarlo visualmente de otros elementos en la página web. Los bordes pueden tener diferentes estilos, anchos y colores, lo que permite personalizar su apariencia y darle un aspecto único a los elementos. */
/* Todo - Estilo de bordes (border-style{}): La propiedad `border-style{}` se utiliza para definir el estilo de los bordes de un elemento HTML. Donde mediante valores podemos definir el tipo de borde que se desea aplicar, como sólido, punteado, discontinuo, doble, entre otros. */
.elemento-con-borde{ /**Se declara un selector por clase llamado "elemento-con-borde-solido".**/
    border-style: solid; /**Se declara una propiedad de estilo de borde con el valor "solid", ocacionando que el borde sea solido.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Dotted */
/* &Declara un estilo de borde punteado, lo que significa que el borde es una línea discontinua con puntos pequeños y espacios entre ellos. */
.elemento-con-borde-tipo-dotted{ /**Se declara un selector por clase llamado "elemento-con-borde-punteado".**/
    border-style: dotted; /**Se declara una propiedad de estilo de borde con el valor "dotted", ocacionando que el borde sea punteado.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Dashed */
/* &Declara un estilo de borde discontinuo, lo que significa que el borde es una línea discontinua con segmentos cortos y espacios entre ellos. */
.elemento-con-borde-tipo-dashed{ /**Se declara un selector por clase llamado "elemento-con-borde-discontinuo".**/
    border-style: dashed; /**Se declara una propiedad de estilo de borde con el valor "dashed", ocacionando que el borde sea discontinuo.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Solid */
/* &Declara un estilo de borde solido, lo que significa que el borde es una línea continua y uniforme. */
.elemento-con-borde-tipo-solido{ /**Se declara un selector por clase llamado "elemento-con-borde-solido".**/
    border-style: solid; /**Se declara una propiedad de estilo de borde con el valor "solid", ocacionando que el borde sea solido.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Double */
/* &Declara un estilo de borde doble, lo que significa que el borde tiene dos líneas paralelas que se ejecutan una al lado de la otra. */
.elemento-con-borde-tipo-double{ /**Se declara un selector por clase llamado "elemento-con-borde-doble".**/
    border-style: double; /**Se declara una propiedad de estilo de borde con el valor "double", ocacionando que el borde sea doble.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Groove */
/* &Declara un estilo de borde surcado, lo que significa que el borde tiene un efecto en relieve que da la apariencia de estar tallado en el elemento. */
.elemento-con-borde-tipo-groove{ /**Se declara un selector por clase llamado "elemento-con-borde-surcado".**/
    border-style: groove; /**Se declara una propiedad de estilo de borde con el valor "groove", ocacionando que el borde sea surcado.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Ridge */
/* &Declara un estilo de borde en relieve, lo que significa que el borde tiene un efecto en relieve que da la apariencia de estar sobresalido del elemento. */
.elemento-con-borde-tipo-ridge{ /**Se declara un selector por clase llamado "elemento-con-borde-en-relieve".**/
    border-style: ridge; /**Se declara una propiedad de estilo de borde con el valor "ridge", ocacionando que el borde sea en relieve.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Inset */
/* &Declara un estilo de borde encajado, lo que significa que el borde tiene un efecto en relieve que da la apariencia de estar hundido en el elemento. */
.elemento-con-borde-tipo-inset{ /**Se declara un selector por clase llamado "elemento-con-borde-encajado".**/
    border-style: inset; /**Se declara una propiedad de estilo de borde con el valor "inset", ocacionando que el borde sea encajado.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Outset */
/* &Declara un estilo de borde saliente, lo que significa que el borde tiene un efecto en relieve que da la apariencia de estar sobresalido del elemento. */
.elemento-con-borde-tipo-outset{ /**Se declara un selector por clase llamado "elemento-con-borde-saliente".**/
    border-style: outset; /**Se declara una propiedad de estilo de borde con el valor "outset", ocacionando que el borde sea saliente.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Hidden */
/* &Declara un estilo de borde oculto, lo que significa que el borde no es visible en el elemento. */
.elemento-con-borde-tipo-hidden{ /**Se declara un selector por clase llamado "elemento-con-borde-oculto".**/
    border-style: hidden; /**Se declara una propiedad de estilo de borde con el valor "hidden", ocacionando que el borde sea oculto.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &None */
/* &Declara un estilo de borde nulo, lo que significa que el borde no se aplica al elemento. */
.elemento-con-borde-tipo-none{ /**Se declara un selector por clase llamado "elemento-con-borde-nulo".**/
    border-style: none; /**Se declara una propiedad de estilo de borde con el valor "none", ocacionando que el borde sea nulo.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Mixed */
/* &Declara un estilo de borde mixto, lo que significa que el borde tiene diferentes estilos en cada lado del elemento. Por lo cual podemos definir cualquier estilo de borde para cada lado del elemento, podiendo ser uno diferente para cada lado. asignando un maximo de cuatro comenzando por el lado superior y siguiendo en sentido horario. Quedando de esta manera (arriba, derecha, abajo, izquierda). En caso de que se definan menos de cuatro estilos, los estilos restantes se repetirán en el orden en que se definieron, por lo que si se definen solo dos estilos, el primero se aplicarán al lado superior y derecho, y el segundo en el lado inferior y izquierdo. */
.elemento-con-borde-tipo-mixto{ /**Se declara un selector por clase llamado "elemento-con-borde-tipo-mixto".**/
    border-style: solid ridge dashed double; /**Se declara una propiedad de estilo de borde con el valor "solid dotted dashed double", ocacionando que el borde sea solido en el lado superior, punteado en el lado derecho, discontinuo en el lado inferior y doble en el lado izquierdo.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Color de bordes (border-color{}): La propiedad `border-color{}` se utiliza para definir el color de los bordes de un elemento HTML. Donde mediante valores podemos definir el color que se desea aplicar a los bordes, ya sea por nombre, hexadecimal, RGB, HSL, entre otros. Ademas de que este color se puede aplicar a cualquier tipo de borde, menos al borde nulo, asi como a cualquier grosor de borde. */
.elemento-con-borde-con-color{ /**Se declara un selector por clase llamado "elemento-con-borde-con-color".**/
    border-style: solid; /**Se declara una propiedad de estilo de borde con el valor "solid", ocacionando que el borde sea solido.**/
    border-color: #ee00ff; /**Se declara una propiedad de color de borde con el valor hexadecimal "#ff0000".**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Grosor de bordes (border-width{}): La propiedad `border-width{}` se utiliza para definir el grosor de los bordes de un elemento HTML. Donde mediante valores podemos definir el grosor que se desea aplicar a los bordes,en cualquier unidad de medida. Ademas de que este grosor se puede aplicar a cualquier tipo de borde, menos al borde nulo, asi como a cualquier color de borde. */
.elemento-con-borde-con-grosor{ /**Se declara un selector por clase llamado "elemento-con-borde-con-grosor".**/
    border-style: solid; /**Se declara una propiedad de estilo de borde con el valor "solid", ocacionando que el borde sea solido.**/
    border-width: 6px; /**Se declara una propiedad de grosor de borde con el valor "5px".**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Shorthand de bordes (border{}): Es una propiedad que engloba todas las propiedades de borde en una sola declaración. Esto permite definir el estilo, el grosor y el color de los bordes en general de un elemento HTML en un solo lugar en este orden (width, style, color). Por lo que nos permite declarar todas estas propiedas sin usar propiedades separadas, lo que facilita la escritura y la lectura del código. Ademas no es necesario integrar todas las propiedades, ya que se pueden omitir algunas si no se desean aplicar. Por lo que la estructura de short-hand de border usando todas las propiedades podria ser border: 5px solid #000000; Por lo que podemos ver que unicamente se usaron los valores de las propiedades que se desean aplicar. */
.elemento-con-borde-shorthand{ /**Se declara un selector por clase llamado "elemento-con-borde-shorthand".**/
    border: 5px dotted yellowgreen; /**Se declara una propiedad de borde con todas las propiedades en una sola declaración.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Bordes individuales (border-top{}, border-right{}, border-bottom{}, border-left{}): Las propiedades `border-top{}`, `border-right{}`, `border-bottom{}` y `border-left{}` se utilizan para definir el estilo, el grosor y el color de los bordes individuales de un elemento HTML, ya que a diferencia del estilo mix ya que este es unicamente para definir estilo por lado, estas propiedades permiten definir el estilo, grosor y color de cada borde de manera individual. Donde al igual que en shorhant podemos declarar el estilo, el grosor y el color de cada borde en una sola declaración. */
.elemento-con-modificacion-de-bordes-individuales{ /**Se declara un selector por clase llamado "elemento-con-modificacion-de-bordes-individuales".**/
    border-top: 2px dashed purple; /**Se declara una propiedad de borde superior con todas las propiedades en una sola declaración.**/
    border-right: 5px dotted blue; /**Se declara una propiedad de borde derecho con todas las propiedades en una sola declaración.**/
    border-bottom: 7px double red; /**Se declara una propiedad de borde inferior con todas las propiedades en una sola declaración.**/
    border-left: 6px solid orange;
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Radio de bordes (border-radius{}): La propiedad `border-radius{}` se utiliza para definir el radio de los bordes de un elemento HTML. Lo que significa redondear las esquinas de un elemento con un borde visible aplicado, ya sea un contenedor, una sección o el cuerpo de la página web. Donde mediante valores podemos definir el radio que se desea aplicar a los bordes, en cualquier unidad de medida. Ademas de que este radio se puede aplicar a cualquier tipo de borde, menos al borde nulo, asi como a cualquier color de borde. Ademas de que podemos definir por separado el radio de cada esquina del elemento, ya sea superior izquierda, superior derecha, inferior izquierda o inferior derecha. Asi mismo se puede definir el radio de los bordes de manera individual usando las propiedades `border-top-left-radius{}`, `border-top-right-radius{}`, `border-bottom-left-radius{}` y `border-bottom-right-radius{}`. */
.elemento-con-borde-con-radio{ /**Se declara un selector por clase llamado "elemento-con-borde-con-radio".**/
    border: solid rgb(0, 71, 79); /**Se declara una propiedad de estilo de borde con el valor "solid", ocacionando que el borde sea solido.**/
    border-radius: 50px 10px 0 30px; /**Se declara una propiedad de radio de borde con el valor "50px 10px 0 120px", ocacionando que el radio de las esquinas sea de 50px en la superior izquierda, 10px en la superior derecha, 0 en la inferior izquierda y 30px en la inferior derecha.**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-borde-con-radio-individual{ /**Se declara un selector por clase llamado "elemento-con-borde-con-radio-individual".**/
    border: solid rgb(0, 71, 79); /**Se declara una propiedad de estilo de borde con el valor "solid", ocacionando que el borde sea solido.**/
    border-top-left-radius: 50px; /**Se declara una propiedad de radio de borde superior izquierdo con el valor "50px", ocacionando que el radio de la esquina superior izquierda sea de 50px.**/
    border-top-right-radius: 10px; /**Se declara una propiedad de radio de borde superior derecho con el valor "10px", ocacionando que el radio de la esquina superior derecha sea de 10px.**/
    border-bottom-left-radius: 0; /**Se declara una propiedad de radio de borde inferior izquierdo con el valor "0", ocacionando que el radio de la esquina inferior izquierda sea de 0.**/
    border-bottom-right-radius: 30px; /**Se declara una propiedad de radio de borde inferior derecho con el valor "30px", ocacionando que el radio de la esquina inferior derecha sea de 30px.**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Margins */
/*  ~Los márgenes en CSS se utilizan para definir el espacio exterior de un elemento, es decir, la distancia entre un elemento y los que lo rodean. Esto ayuda a separar visualmente los elementos y a crear espacios en blanco para mejorar la organización del contenido. Los márgenes pueden aplicarse a cualquier elemento HTML, como contenedores, secciones, imágenes, botones, etc. Se pueden definir de forma individual para cada lado o aplicar un margen general en todas las direcciones. */
/* Todo - Margenes individuales (margin-top{}, margin-right{}, margin-bottom{}, margin-left{}): Las propiedades `margin-top{}`, `margin-right{}`, `margin-bottom{}` y `margin-left{}` se utilizan para definir el margen de un elemento HTML en cada lado de manera individual, modificando de esta manera un lado especifico del elemento. Donde mediante valores podemos definir el margen que se desea aplicar a cada lado, en cualquier unidad de medida. */
.elemento-con-margenes-individuales{ /**Se declara un selector por clase llamado "elemento-con-margenes-individuales".**/
    background-color: #fffd80; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#fffd80".**/
    margin-top: 10px; /**Se declara una propiedad de margen superior con el valor "10px".**/
    margin-right: 250px; /**Se declara una propiedad de margen derecho con el valor "20px".**/
    margin-bottom: 30px; /**Se declara una propiedad de margen inferior con el valor "30px".**/
    margin-left: 20px; /**Se declara una propiedad de margen izquierdo con el valor "40px".**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Margenes con shorthand (margin{}): La propiedad `margin{}` se utiliza para definir el margen de un elemento HTML en todas las direcciones de manera general, modificando de esta manera todos los lados del elemento. Donde mediante valores podemos definir el margen que se desea aplicar a todos los lados, en cualquier unidad de medida. Por lo que para asignar el margen de los cuatro lados se debe seguir el siguiente orden (arriba, derecha, abajo, izquierda). Podiendo quedar de la siguiente manera margin: 10px 20px 30px 40px; haciendo que el margen superior sea de 10px, el margen derecho de 20px, el margen inferior de 30px y el margen izquierdo de 40px. Pero si se ingresa un solo valor, este se aplicará a todos los lados, si se ingresan dos valores, el primero se aplicará al margen superior e inferior, y el segundo al margen derecho e izquierdo, y si se ingresan tres valores, el primero se aplicará al margen superior, el segundo al margen derecho e izquierdo, y el tercero al margen inferior. */
.elemento-con-margenes-shorthand-con-un-valor{ /**Se declara un selector por clase llamado "elemento-con-margenes-shorthand-con-un-valor".**/
    background-color: #fffd80; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#fffd80".**/
    margin: 50px; /**Se declara una propiedad de margen con el valor "10px 20px 30px 40px".**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-margenes-shorthand-con-dos-valores{
    background-color: #fffd80; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#fffd80".**/
    margin: 20px 100px; /**Se declara una propiedad de margen con el valor "10px 20px 30px 40px".**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-margenes-shorthand{ /**Se declara un selector por clase llamado "elemento-con-margenes-shorthand".**/
    background-color: #fffd80;  /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#fffd80".**/
    margin: 50px 60px 30px 170px; /**Se declara una propiedad de margen con el valor "10px 20px 30px 40px".**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Padding */
/*  ~El padding en CSS es muy similar a margin, pero en este caso se utiliza para definir el espacio interior de un elemento, es decir, la distancia entre el contenido de un elemento y su borde. Esto ayuda a separar visualmente el contenido del borde y a crear espacios en blanco dentro del elemento. El padding puede aplicarse a cualquier elemento HTML, como contenedores, secciones, imágenes, botones, etc. Se pueden definir de forma individual para cada lado o aplicar un padding general en todas las direcciones. */
/* Todo - Paddings individuales (padding-top{}, padding-right{}, padding-bottom{}, padding-left{}): Las propiedades `padding-top{}`, `padding-right{}`, `padding-bottom{}` y `padding-left{}` se utilizan para definir el padding de un elemento HTML en cada lado de manera individual, modificando de esta manera un lado especifico del elemento. Donde mediante valores podemos definir el padding que se desea aplicar a cada lado, en cualquier unidad de medida. */
.elemento-con-paddings-individuales{ /**Se declara un selector por clase llamado "elemento-con-paddings-individuales".**/
    background-color: #e880ff; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#e880ff".**/
    border: solid black; /**Se declara una propiedad de estilo de borde con el valor "solid", ocacionando que el borde sea solido.**/
    padding-top: 10px; /**Se declara una propiedad de padding superior con el valor "10px".**/
    padding-right: 30px; /**Se declara una propiedad de padding derecho con el valor "20px".**/
    padding-bottom: 50px; /**Se declara una propiedad de padding inferior con el valor "30px".**/
    padding-left: 70px; /**Se declara una propiedad de padding izquierdo con el valor "40px".**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Shorthand de paddings (padding{}): La propiedad `padding{}` se utiliza para definir el padding de un elemento HTML en todas las direcciones con diferentes valores al mismo tiempo, modificando de esta manera todos los lados del elemento. Donde mediante valores podemos definir el padding que se desea aplicar a todos los lados, en cualquier unidad de medida. Por lo que para asignar el padding de los cuatro lados se debe seguir el siguiente orden (arriba, derecha, abajo, izquierda). Podiendo quedar de la siguiente manera padding: 10px 20px 30px 40px; haciendo que el padding superior sea de 10px, el padding derecho de 20px, el padding inferior de 30px y el padding izquierdo de 40px. Pero si se ingresa un solo valor, este se aplicará a todos los lados, si se ingresan dos valores, el primero se aplicará al padding superior e inferior, y el segundo al padding derecho e izquierdo, y si se ingresan tres valores, el primero se aplicará al padding superior, el segundo al padding derecho e izquierdo, y el tercero al padding inferior. */
.elemento-con-paddings-shorthand-con-un-valor{ /**Se declara un selector por clase llamado "elemento-con-paddings-shorthand-con-un-valor".**/
    background-color: #e880ff; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#e880ff".**/
    border: solid black; /**Se declara una propiedad de estilo de borde con el valor "solid", ocacionando que el borde sea solido.**/
    padding: 50px; /**Se declara una propiedad de padding con el valor "10px 20px 30px 40px".**/
} /**Cierre de la declaracion de selector por clase.**/ 

.elemento-con-paddings-shorthand-con-dos-valores{
    background-color: #e880ff; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#e880ff".**/
    border: solid black; /**Se declara una propiedad de estilo de borde con el valor "solid", ocacionando que el borde sea solido.**/
    padding: 20px 40px; /**Se declara una propiedad de padding con el valor "10px 20px 30px 40px".**/
}

.elemento-con-paddings-shorthand{ /**Se declara un selector por clase llamado "elemento-con-paddings-shorthand".**/
    background-color: #e880ff; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#e880ff".**/
    border: solid black; /**Se declara una propiedad de estilo de borde con el valor "solid", ocacionando que el borde sea solido.**/
    padding: 10px 20px 30px 40px; /**Se declara una propiedad de padding con el valor "10px 20px 30px 40px".**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Height/Width */
/* ~El height y width en CSS se utilizan para definir el tamaño de un elemento HTML, es decir, la altura y el ancho del elemento. Esto permite controlar las dimensiones de un elemento y ajustar su tamaño para que se adapte a las necesidades del diseño. Los valores de height y width se pueden definir en diferentes unidades de medida, como píxeles, porcentajes, ems, entre otros. */
/* Todo - Height (height{}): La propiedad `height{}` se utiliza para definir la altura de un elemento HTML. Donde mediante valores podemos definir la altura que se desea aplicar al elemento, en cualquier unidad de medida. */
.elemento-con-altura{ /**Se declara un selector por clase llamado "elemento-con-altura".**/
    background-color: #f7ff80; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#80ff80".**/
    height: 100px; /**Se declara una propiedad de altura con el valor "200px".**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Width (width{}): La propiedad `width{}` se utiliza para definir el ancho de un elemento HTML. Donde mediante valores podemos definir el ancho que se desea aplicar al elemento, en cualquier unidad de medida. */
.elemento-con-ancho{ /**Se declara un selector por clase llamado "elemento-con-ancho".**/
    background-color: #f7ff80; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#80ff80".**/
    width: 400px; /**Se declara una propiedad de ancho con el valor "300px".**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Height y Width Minimos (min-height{}, min-width{}): Las propiedades `min-height{}` y `min-width{}` se utilizan para definir la altura y el ancho mínimos de un elemento HTML, respectivamente. Donde mediante valores podemos definir la altura y el ancho mínimos que se desea aplicar al elemento, en cualquier unidad de medida. Por lo que el tamaño minimo en el heght tomara dicho valor minimo si no hay contenido que lo haga crecer, y el width tomara el maximo, esto debido a que es un elemento de bloque el cual se expandira hasta el maximo posible, siempre que pueda. */
.elemento-con-altura-minima{ /**Se declara un selector por clase llamado "elemento-con-altura-minima".**/
    background-color: #80ffb9; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#80ff80".**/
    min-height: 100px; /**Se declara una propiedad de altura minima con el valor "200px".**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-ancho-minimo{ /**Se declara un selector por clase llamado "elemento-con-ancho-minimo".**/
    background-color: #80ffb9; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#80ff80".**/
    min-width: 200px; /**Se declara una propiedad de ancho minimo con el valor "300px".**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-ancho-y-alto-minimo{
    background-color: #80ffb9; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#80ff80".**/
    min-height: 100px; /**Se declara una propiedad de altura minima con el valor "200px".**/
    min-width: 200px; /**Se declara una propiedad de ancho minimo con el valor "300px".**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Heigh y Width Maximos (max-height{}, max-width{}): Las propiedades `max-height{}` y `max-width{}` se utilizan para definir la altura y el ancho máximos de un elemento HTML, respectivamente. Donde mediante valores podemos definir la altura y el ancho máximos que se desea aplicar al elemento, en cualquier unidad de medida. Por lo que el tamaño maximo en el heght tomara dicho valor maximo si no hay contenido que lo haga crecer, y el width tomara el maximo, esto debido a que es un elemento de bloque el cual se expandira hasta el maximo posible, siempre que pueda. Por lo que si el contenido supera el maximo, el contenido se saldra del elemento ya que este no se expandira mas, ademas si no se establece un min y no hay contenido dentro del elemento este se reducira hasta tocar sus bordes, por ejemplo si se establece un max en height y no hay contenido dentro del elemento, este se reducira hasta tocar sus bordes en el borde superior e inferior e igualmente pasa con el width, por lo que si se establece un max en height y no hay contenido dentro del elemento, este se reducira hasta tocar sus bordes en el borde izquierdo y derecho. */
.elemento-con-altura-maxima{ /**Se declara un selector por clase llamado "elemento-con-altura-maxima".**/
    background-color: #d0a2ff; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#80ff80".**/
    max-height: 200px; /**Se declara una propiedad de altura maxima con el valor "200px".**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-ancho-maximo{ /**Se declara un selector por clase llamado "elemento-con-ancho-maximo".**/
    background-color: #d0a2ff; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#80ff80".**/
    max-width: 700px; /**Se declara una propiedad de ancho maxima con el valor "300px".**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-ancho-y-alto-maximo{ /**Se declara un selector por clase llamado "elemento-con-ancho-y-altura-maxima".**/
    background-color: #d0a2ff; /**Se asigna una propiedad de color de fondo con el valor hexadecimal "#80ff80".**/
    max-height: 25px; /**Se declara una propiedad de altura maxima con el valor "200px".**/
    max-width: 300px; /**Se declara una propiedad de ancho maxima con el valor "300px".**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Texto */
/* ~El texto en CSS se refiere a la forma en que se presenta el contenido textual en una página web. Esto incluye la tipografía, el tamaño, el color, el espaciado y otros aspectos visuales del texto. CSS permite personalizar la apariencia del texto para que se ajuste al diseño y estilo de la página web. */
/* Todo -  Color de texto (color{}): La propiedad `color{}` se utiliza para definir el color del texto de un elemento HTML. Donde mediante valores podemos definir el color que se desea aplicar al texto, ya sea por nombre, hexadecimal, RGB, HSL, entre otros. */
.elemento-con-color-de-texto{ /**Se declara un selector por clase llamado "elemento-con-color-de-texto".**/
    color: #ff7700; /**Se declara una propiedad de color de texto con el valor hexadecimal "#ff0000".**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Alineamiento de texto (text-align{}): Por defecto el texto siempre se alinea a la izquierda, pero mediante la propiedad `text-align{}` podemos definir la alineación del texto de un elemento HTML. Donde mediante valores podemos definir la alineación que se desea aplicar al texto, como izquierda, derecha, centro o justificar. */
.elemento-con-alineacion-de-texto-a-la-izquierda{ /**Se declara un selector por clase llamado "elemento-con-alineacion-de-texto".**/
    text-align: left; /**Se declara una propiedad de alineación de texto con el valor "center", ocacionando que el texto se alinee al centro.**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-alineacion-de-texto-centrado{ /**Se declara un selector por clase llamado "elemento-con-alineacion-de-texto".**/
    text-align: center; /**Se declara una propiedad de alineación de texto con el valor "center", ocacionando que el texto se alinee al centro.**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-alineacion-a-la-derecha{ /**Se declara un selector por clase llamado "elemento-con-alineacion-a-la-derecha".**/
    text-align: right; /**Se declara una propiedad de alineación de texto con el valor "center", ocacionando que el texto se alinee al centro.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Formato de subrayado de texto: El formato de subrayado de texto se refiere a la forma en que se aplica el subrayado a un texto en CSS. Esto incluye la aplicación de diferentes estilos de subrayado, como subrayado simple, doble, tachado, sobrelineado, asi como las porpiedades del mismo, como el color y el grosor. */
/* ^Subrayado de texto (text-decoration-line{}): La propiedad `text-decoration-line{}` se utiliza para definir el estilo de subrayado de un elemento HTML. Donde mediante valores podemos definir el estilo que se desea aplicar al subrayado, como subrayado simple, doble, tachado, sobrelineado, entre otros. */
/* &Underline */
/* &Declara un estilo de subrayado, lo que significa que el texto tendrá una línea debajo de él. */
.elemento-con-text-decoration-underline{ /**Se declara un selector por clase llamado "elemento-con-text-decoration-underline".**/
    text-decoration-line: underline; /**Se declara una propiedad de subrayado de texto con el valor "underline", ocacionando que el texto se subraye.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Line-through */
/* &Declara un estilo de tachado, lo que significa que el texto tendrá una línea a través de él. */ 
.elemento-con-text-decoration-line-throught{ /**Se declara un selector por clase llamado "elemento-con-text-decoration-line-throught".**/
    text-decoration-line: line-through; /**Se declara una propiedad de tachado de texto con el valor "line-through", ocacionando que el texto se tache.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Overline */
/* &Declara un estilo de sobrelineado, lo que significa que el texto tendrá una línea encima de él. */
.elemento-con-text-decoration-overline{ /**Se declara un selector por clase llamado "elemento-con-text-decoration-overline".**/
    text-decoration-line: overline; /**Se declara una propiedad de subrayado de texto con el valor "underline", ocacionando que el texto se subraye.**/
} /**Cierre de la declaracion de selector por clase.**/

/* ^Color de subrayado de texto (text-decoration-color{}): La propiedad `text-decoration-color{}` se utiliza para definir el color del subrayado de un elemento HTML. Donde mediante valores podemos definir el color que se desea aplicar al subrayado, ya sea por nombre, hexadecimal, RGB, HSL, entre otros. */
.elemento-con-text-decoration-con-color{ /**Se declara un selector por clase llamado "elemento-con-text-decoration-de-color".**/
    text-decoration-line: underline; /**Se declara una propiedad de subrayado de texto con el valor "underline", ocacionando que el texto se subraye.**/
    text-decoration-color: rgb(255, 0, 0); /**Se declara una propiedad de color de subrayado de texto con el valor "red", ocacionando que el subrayado sea rojo.**/
}

/* ^Estilo del subrayado de texto(text-decoration-style{}): La propiedad `text-decoration-style{}` se utiliza para definir el estilo del subrayado de un elemento HTML. Donde mediante valores podemos definir el estilo que se desea aplicar al subrayado podiendo utilizar solido, punteado, discontinuo, entre otros. */
/* &Dotted */
/* &Declara un estilo de subrayado punteado, lo que significa que el subrayado será una serie de puntos. */
.elemento-con-text-decoration-style-dashed{ /** Se declara un selector por clase llamado "elemento-con-text-decoration-style-dashed".**/
    text-decoration-line: underline; /***Se declara una propiedad de subrayado de texto con el valor "underline", ocacionando que el texto se subraye.**/
    text-decoration-style: dashed; /**Se declara una propiedad de estilo de subrayado de texto con el valor "dashed", ocacionando que el subrayado sea discontinuo.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Dashed */
/* &Declara un estilo de subrayado discontinuo, lo que significa que el subrayado será una serie de líneas discontinuas. */
.elemento-con-text-decoration-style-dotted{ /**Se declara un selector por clase llamado "elemento-con-text-decoration-style-dotted".**/
    text-decoration-line: underline; /**Se declara una propiedad de subrayado de texto con el valor "underline", ocacionando que el texto se subraye.**/
    text-decoration-style: dotted; /**Se declara una propiedad de estilo de subrayado de texto con el valor "dotted", ocacionando que el subrayado sea punteado.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Solid */
/* &Declara un estilo de subrayado solido, lo que significa que el subrayado será una línea continua. */
.elemento-con-text-decoration-style-solid{
    text-decoration-line: underline; /**Se declara una propiedad de subrayado de texto con el valor "underline", ocacionando que el texto se subraye.**/
    text-decoration-style: solid; /**Se declara una propiedad de estilo de subrayado de texto con el valor "solid", ocacionando que el subrayado sea solido.**/
}

/* &Double */
/* &Declara un estilo de subrayado doble, lo que significa que el subrayado será una serie de dos líneas continuas. */
.elemento-con-text-decoration-style-double{ /**Se declara un selector por clase llamado "elemento-con-text-decoration-style-double".**/
    text-decoration-line: underline; /**Se declara una propiedad de subrayado de texto con el valor "underline", ocacionando que el texto se subraye.**/
    text-decoration-style: double; /**Se declara una propiedad de estilo de subrayado de texto con el valor "double", ocacionando que el subrayado sea doble.**/
} /**Cierre de la declaracion de selector por clase.**/
/* &wavy */
/* &Declara un estilo de subrayado ondulado, lo que significa que el subrayado será una serie de líneas onduladas. */
.elemento-con-text-decoration-style-wavy{ /**Se declara un selector por clase llamado "elemento-con-text-decoration-style-gavy".**/
    text-decoration-line: underline; /**Se declara una propiedad de subrayado de texto con el valor "underline", ocacionando que el texto se subraye.**/
    text-decoration-style: wavy; /**Se declara una propiedad de estilo de subrayado de texto con el valor "wavy", ocacionando que el subrayado sea ondulado.**/
} /**Cierre de la declaracion de selector por clase.**/

/* ^Grosor del subrayado de texto (text-decoration-thickness{}): La propiedad `text-decoration-thickness{}` se utiliza para definir el grosor del subrayado de un elemento HTML. Donde mediante valores podemos definir el grosor que se desea aplicar al subrayado, en cualquier unidad de medida. */
.elemento-con-text-decoration-con-grosor{ /**Se declara un selector por clase llamado "elemento-con-text-decoration-thickness".**/
    text-decoration-line: underline; /**Se declara una propiedad de subrayado de texto con el valor "underline", ocacionando que el texto se subraye.**/
    text-decoration-thickness: 5px; /**Se declara una propiedad de grosor de subrayado de texto con el valor "5px", ocacionando que el subrayado sea de 5px.**/
} /**Cierre de la declaracion de selector por clase.**/

/* ^Formato de subrayado de texto con shorthand (text-decoration{}): La propiedad `text-decoration{}` se utiliza para definir el formato del subrayado de un elemento HTML. Donde se puede definir lo antes mencionado, como el tipo del subrayado, el color del subrayado, el grosor del subrayado y el estilo de subrayado. Por lo que mediante valores podemos definir el formato que se desea aplicar al subrayado, en cualquier unidad de medida. Por ende se debe de declarar el formato de subrayado de la siguiente manera: text-decoration: underline red 5px solid; donde el primer valor es el tipo de subrayado, el segundo valor es el estilo del subrayado, el tercer valor es el color del subrayado y el cuarto valor es el grosor del subrayado. */
.elemento-con-text-decoration-shorthand{ /**Se declara un selector por clase llamado "elemento-con-text-decoration-shorthand".**/
    text-decoration: overline dotted rgb(200, 0, 255) 3px ; /**Se declara una propiedad de formato de subrayado de texto con el valor "underline red 5px solid", ocacionando que el subrayado sea de tipo subrayado, color rojo, grosor de 5px y estilo solido.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Transformacion de texto (text-transform{}): La propiedad `text-transform{}` se utiliza para definir la transformación del texto de un elemento HTML. Donde mediante valores podemos convertir el texto elemento a mayúsculas, minúsculas, capitalizar la primera letra de cada palabra o dejarlo sin transformación. Esto aplica incluso si se usaron tanto mayusculas como minusculas al mismo tiempo en el texto del elemento. */
/* &Uppercase */
/* &Declara un estilo de texto en mayúsculas, lo que significa que el texto se mostrará en mayúsculas. */
.elemento-con-text-transform-uppercase{ /**Se declara un selector por clase llamado "elemento-con-text-transform-uppercase".**/
    text-transform: uppercase; /**Se declara una propiedad de transformación de texto con el valor "uppercase", ocacionando que el texto se muestre en mayúsculas.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Lowercase */
/* &Declara un estilo de texto en minúsculas, lo que significa que el texto se mostrará en minúsculas. */
.elemento-con-text-transform-lowercase{
    text-transform: lowercase; /**Se declara una propiedad de transformación de texto con el valor "lowercase", ocacionando que el texto se muestre en minúsculas.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Capitalize */
/* &Declara un estilo de texto capitalizado, lo que significa que la primera letra de cada palabra se mostrará en mayúsculas. */
.elemento-con-text-transform-capitalize{ /**Se declara un selector por clase llamado "elemento-con-text-transform-capitalize".**/
    text-transform: capitalize; /**Se declara una propiedad de transformación de texto con el valor "capitalize", ocacionando que la primera letra de cada palabra se muestre en mayúsculas.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Sangria de texto (text-indent{}): La propiedad `text-indent{}` se utiliza para definir la sangría del texto de un elemento HTML. Donde mediante valores podemos definir la sangría que se desea aplicar al texto, en cualquier unidad de medida. Por lo que la sangria se aplicara al primer renglon del texto del elemento. Dicha sangria afecta unicamente a la primera linea del texto del elemento. */
.elemento-con-text-indent{ /**Se declara un selector por clase llamado "elemento-con-text-indent".**/
    text-indent: 50px; /**Se declara una propiedad de sangria de texto con el valor "50px", ocacionando que la sangria del texto sea de 50px.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Espaciado entre letras (letter-spacing{}): La propiedad `letter-spacing{}` se utiliza para definir el espaciado entre letras de un elemento HTML. Donde mediante valores podemos definir el espaciado que se desea aplicar entre letras, en cualquier unidad de medida. Asi mismo se podran utilizar valores negativos, lo que hara que el espaciado entre letras sea menor al normal. */
.elemento-con-letter-spacing-positivo{ /**Se declara un selector por clase llamado "elemento-con-letter-spacing-positivo".**/
    letter-spacing: 10px; /**Se declara una propiedad de espaciado entre letras con el valor "10px", ocacionando que el espaciado entre letras sea de 10px.**/
} /**Cierre de la declaracion de selector por clase.**/  

.elemento-con-letter-spacing-negativo{ /**Se declara un selector por clase llamado "elemento-con-letter-spacing-negativo".**/ 
    letter-spacing: -2px; /**Se declara una propiedad de espaciado entre letras con el valor "-10px", ocacionando que el espaciado entre letras sea de -2px.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Espaciado entre palabras (word-spacing{}): La propiedad `word-spacing{}` se utiliza para definir el espaciado entre palabras de un elemento HTML. Donde mediante valores podemos definir el espaciado que se desea aplicar entre palabras, en cualquier unidad de medida. */
.elemento-con-word-spacing-positivo{ /**Se declara un selector por clase llamado "elemento-con-word-spacing-positivo".**/
    word-spacing: 10px; /**Se declara una propiedad de espaciado entre palabras con el valor "10px", ocacionando que el espaciado entre palabras sea de 10px.**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-word-spacing-negativo{ /**Se declara un selector por clase llamado "elemento-con-word-spacing-negativo".**/
    word-spacing: -4px; /**Se declara una propiedad de espaciado entre palabras con el valor "-4px", ocacionando que el espaciado entre palabras sea de -2px.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Espaciado entre lineas (line-height{}): La propiedad `line-height{}` se utiliza para definir el espaciado entre una linea y otra de un elemento HTML. Donde mediante valores podemos definir el espaciado que se desea aplicar entre lineas, en cualquier unidad de medida. Por lo que el espaciado entre lineas se aplicara a todas las lineas del texto del elemento. */
.elemento-con-line-height{
    line-height: 50px;
}

/* Todo- Texto no limitado a contenedor (white-space{}): La propiedad `white-space{}` se utiliza para definir el comportamiento del texto dentro de un elemento HTML. Donde mediante valores podemos definir el comportamiento que se desea aplicar al texto, como por ejemplo si se desea que el texto se ajuste al ancho del contenedor, si se desea que el texto se mantenga en una sola línea, si se desea que el texto se ajuste al ancho del contenedor y se mantenga en una sola línea, entre otros. */
/* &Nowrap */
/* &Declara un comportamiento de texto sin ajuste, lo que significa que el texto no se ajustará al ancho del contenedor y se mantendrá en una sola línea siempre. */
.elemento-con-white-space-nowrap{ /**Se declara un selector por clase llamado "elemento-con-white-space-nowrap".**/
    white-space: nowrap; /**Se declara una propiedad de comportamiento de texto con el valor "nowrap", ocacionando que el texto no se ajuste al ancho del contenedor y se mantenga en una sola línea.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Pre */
/* &Declara un comportamiento de texto preformateado, lo que significa que el texto se mostrará tal como se escribió en el código HTML, incluyendo espacios y saltos de línea. */
.elemento-con-white-space-pre{ /**Se declara un selector por clase llamado "elemento-con-white-space-pre".**/
    white-space: pre; /**Se declara una propiedad de comportamiento de texto con el valor "pre", ocacionando que el texto se muestre tal como se escribió en el código HTML, incluyendo espacios y saltos de línea.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Pre-wrap */
/* &Declara un comportamiento de texto preformateado con ajuste, lo que significa que el texto se mostrará tal como se escribió en el código HTML, incluyendo espacios y saltos de línea, pero se ajustará al ancho del contenedor. */
.elemento-con-white-space-prewrap{ /**Se declara un selector por clase llamado "elemento-con-white-space-prewrap".**/
    white-space: pre-wrap; /**Se declara una propiedad de comportamiento de texto con el valor "pre-wrap", ocacionando que el texto se muestre tal como se escribió en el código HTML, incluyendo espacios y saltos de línea, pero se ajustará al ancho del contenedor.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Sombra de texto (text-shadow{}): La propiedad `text-shadow{}` se utiliza para definir la sombra de un texto de un elemento HTML. Donde mediante valores podemos definir la sombra que se desea aplicar al texto, en cualquier unidad de medida. Por lo que la sombra se aplicara a todo el texto del elemento. Declaracion de la sombra cuenta con cuatro valores, donde el primer valor es el desplazamiento horizontal de la sombra, el segundo valor es el desplazamiento vertical de la sombra, el tercer valor es el difuminado de la sombra y el cuarto valor es el color de la sombra. Por lo que si se desea una sombra sin difuminado se puede omitir el tercer valor. De igual manera se pueden estrablecer mas de una sombra al mismo tiempo, separando cada sombra con una coma y declarando cada sombra con los cuatro valores antes mencionados. */
.elemento-con-un-text-shadow{ /**Se declara un selector por clase llamado "elemento-con-un-text-shadow".**/
    text-shadow: 7px 7px 4px black; /**Se declara una propiedad de de sombreado de texto con el valor "text-shadow" , ocacionando que el texto tenga una sombra de 7px de desplazamiento horizontal, 7px de desplazamiento vertical y 4px de difuminado.**/
} /**Cierre de la declaración de selector por clase.**/

.elemento-con-dos-text-shadow{ /**Se declara un selector por clase llamado "elemento-con-dos-text-shadow".**/
    text-shadow: 5px 25px 5px black, 10px 10px 2px red; /**Se declara una propiedad de de sombreado de texto con el valor "text-shadow" , ocacionando que el texto tenga dos sombras, la primera sombra tiene un desplazamiento horizontal de 5px, un desplazamiento vertical de 25px y un difuminado de 5px, y la segunda sombra tiene un desplazamiento horizontal de 10px, un desplazamiento vertical de 10px y un difuminado de 2px.**/
} /**Cierre de la declaración de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Fuentes */
/* ~La fuente en CSS se refiere al estilo y apariencia del texto en una página web. Esto incluye la elección de la familia de fuentes, el tamaño, el peso, el estilo y otros aspectos visuales de la tipografía. CSS permite personalizar la apariencia de las fuentes para que se ajusten al diseño y estilo de la página web. */
/* Todo -  Familia de fuente de texto (font-family{}): La propiedad `font-family{}` se utiliza para definir la familia de fuente de un elemento HTML. Donde mediante valores podemos definir la familia de fuente que se desea aplicar al texto, como Arial, Helvetica, Times New Roman, entre otros. Cabe mencionar que cada opcion contiene varias fuentes, por lo que si no se encuentra la fuente especifica, el navegador buscara la siguiente en la lista. Por lo que si se desea utilizar una fuente personalizada, se debe de importar la fuente desde un archivo externo o desde una URL. */
/* &Disponible en el sistema */
/* &Declara una familia de fuente disponible en el sistema, lo que significa que el texto se mostrará con la fuente especificada. */
.elemento-con-font-family-del-sistema{ /**Se declara un selector por clase llamado "elemento-con-font-family".**/
    font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif; /**Se declara una propiedad de familia de fuente con el valor "Arial", ocacionando que la fuente del texto sea Arial. Adicionalmente se agregan otras fuentes como respaldo, en caso de que la fuente principal no esté disponible.**/
} /**Cierre de la declaracion de selector por clase.**/

/*&Externa */
/* &Declara una familia de fuente externa, lo que significa que el texto se mostrará con la fuente especificada. */
.elemento-con-font-family-externa{
    font-family: "Dancing Script", cursive;
}

/* Todo - Estilo de fuente (font-style{}): La propiedad `font-style{}` se utiliza para definir el estilo de fuente de un elemento HTML. Donde mediante valores podemos definir el estilo que se desea aplicar a la fuente, como normal o cursiva. */
/* &Italic */
/* &Declara un estilo de fuente en cursiva, lo que significa que el texto se mostrará en cursiva. */
.elemento-con-font-style-italic{ /**Se declara un selector por clase llamado "elemento-con-font-style-italic".**/
    font-style: italic; /**Se declara una propiedad de estilo de fuente con el valor "italic", ocacionando que la fuente del texto sea en cursiva.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Normal */
/* &Declara un estilo de fuente normal, lo que significa que el texto se mostrara con el estilo por defecto. */
.elemento-con-font-style-normal{ /**Se declara un selector por clase llamado "elemento-con-font-style-normal".**/
    font-style: normal; /**Se declara una propiedad de estilo de fuente con el valor "normal", ocacionando que la fuente del texto sea normal.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Peso de fuente (font-weight{}): La propiedad `font-weight{}` se utiliza para definir el peso de fuente de un elemento HTML. Donde mediante valores podemos definir el peso que se desea aplicar a la fuente, como normal o negrita */
/* &Bold */
/* &Declara un peso de fuente en negrita, lo que significa que el texto se mostrará en negrita. */
.elemento-con-font-weight-bold{ /**Se declara un selector por clase llamado "elemento-con-font-weight-bold".**/
    font-weight: bold; /**Se declara una propiedad de peso de fuente con el valor "bold", ocacionando que la fuente del texto sea en negrita.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Normal */
/* &Declara un peso de fuente normal, lo que significa que el texto se mostrara con el peso por defecto. */
.elemento-con-font-weight-normal{ /**Se declara un selector por clase llamado "elemento-con-font-weight-normal".**/
    font-weight: normal; /**Se declara una propiedad de peso de fuente con el valor "normal", ocacionando que la fuente del texto sea normal.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Variante de fuente (font-variant{}): La propiedad `font-variant{}` se utiliza para definir la variante de fuente de un elemento HTML. Donde mediante valores podemos definir la variante que se desea aplicar a la fuente, como normal o pequeña mayúscula. Esto significa que el texto se mostrará en mayúsculas, pero con un tamaño de fuente más pequeño que el resto del texto. */
/* &Small-caps */
/* &Declara una variante de fuente en mayúsculas pequeñas, lo que significa que el texto se mostrará en mayúsculas pequeñas. */
.elemento-con-font-variant-small-caps{ /**Se declara un selector por clase llamado "elemento-con-font-variant-small-caps".**/
    font-variant: small-caps; /**Se declara una propiedad de variante de fuente con el valor "small-caps", ocacionando que la fuente del texto sea en mayúsculas pequeñas.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Normal */
/* &Declara una variante de fuente normal, lo que significa que el texto se mostrara con la variante por defecto. */
.elemento-con-font-variant-normal{ /**Se declara un selector por clase llamado "elemento-con-font-variant-normal".**/
    font-variant: normal; /**Se declara una propiedad de variante de fuente con el valor "normal", ocacionando que la fuente del texto sea normal.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Tamaño de fuente (font-size{}): La propiedad `font-size{}` se utiliza para definir el tamaño de fuente de un elemento HTML. Donde mediante valores podemos definir el tamaño que se desea aplicar a la fuente, en cualquier unidad de medida. Por lo que el tamaño de fuente se aplicara a todo el texto del elemento. Dicho tamaño se puede declarar mediante cualquier unidad de medida, como px, em, rem, %, entre otros, ademas de poder utilizar palabras reservadas como "large", "medium", "small", entre otros. Que significan grande, mediano y pequeño respectivamente. */
.elemento-con-font-size{ /**Se declara un selector por clase llamado "elemento-con-font-size".**/
    font-size: smaller; /**Se declara una propiedad de tamaño de fuente con el valor "large", ocacionando que la fuente del texto sea grande.**/
} /**Se declara una propiedad de tamaño de fuente con el valor "large", ocacionando que la fuente del texto sea grande.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Listas */
/* ~Las listas en CSS se refieren a la forma en que se presentan los elementos de una lista en una página web. Esto incluye la elección del tipo de lista, el estilo de los elementos de la lista, el espaciado y otros aspectos visuales de las listas. CSS permite personalizar la apariencia de las listas para que se ajusten al diseño y estilo de la página web. */
/* Todo - Tipo de estilo de lista (list-style-type{}): La propiedad `list-style-type{}` se utiliza para definir el estilo de una lista en un elemento HTML. Donde mediante valores podemos definir el estilo que se desea aplicar a la lista, como ninguno, disc, circle, square, entre otros. Esto va mas enfocado a el tipo de simbolo o numeracion que se desea aplicar a la lista. Por defecto las listas desordenadas utilizan un simbolo de punto, y las listas ordenadas utilizan una numeracion decimal. */
.elemento-con-list-style-type{ /**Se declara un selector por clase llamado "elemento-con-list-style-type".**/
    list-style-type: disc; /**Se declara una propiedad de estilo de lista con el valor "disc", ocacionando que la lista tenga un simbolo de punto.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Tipo de estilo de lista con imagen (list-style-image{}): La propiedad `list-style-image{}` se utiliza para definir el estilo de una lista en un elemento HTML. Donde mediante valores podemos definir el estilo que se desea aplicar a la lista, como ninguno, disc, circle, square, entre otros. Esto va mas enfocado a el tipo de simbolo o numeracion que se desea aplicar a la lista. Por defecto las listas desordenadas utilizan un simbolo de punto, y las listas ordenadas utilizan una numeracion decimal. */
.elemento-con-list-style-image{ /**Se declara un selector por clase llamado "elemento-con-list-style-image".**/
    list-style-image: url(../assets/icons/The_Legend_Of_Zelda_Icon.png) /**Se declara una propiedad de estilo de lista con el valor "url(../assets/icons/The_Legend_Of_Zelda_Icon.png)", ocacionando que la lista tenga un simbolo de imagen.**/
}  /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Tablas */
/* ~Las tablas en CSS se refieren a la forma en que se presentan los datos tabulares en una página web. Esto incluye la elección del estilo de la tabla, el espaciado, el borde, el color de fondo y otros aspectos visuales de las tablas. CSS permite personalizar la apariencia de las tablas para que se ajusten al diseño y estilo de la página web. */
/* Todo - Colapso de bordes (border-collapse{}): La propiedad `border-collapse{}` se utiliza para definir el colapso de bordes de una tabla en un elemento HTML. Donde mediante valores podemos definir el colapso que se desea aplicar a la tabla, como separado o colapsado. Esto significa que los bordes de las celdas de la tabla se mostrarán separados o colapsados entre sí. Esti significa que por defecto cada celda tiene  su propio borde, pero si se desea que los bordes de las celdas se unan, se debe de utilizar la propiedad `border-collapse: collapse;`. Para que esto sea visible es necesario que la tabla tenga un borde definido. */
table,th,tr,td{ /**Se declaran los selectores por etiqueta de la tabla, el encabezado de la tabla, la fila de la tabla y la celda de la tabla.**/
    border: 1px solid black; /**Se declara un borde con el valor "1px solid black", ocacionando que la tabla tenga un borde de 1px de grosor, solido.**/
} /**Se declara un borde con el valor "1px solid black", ocacionando que la tabla tenga un borde de 1px de grosor, solido

/* &Separate */
/* &Declara un colapso de bordes separado, lo que significa que los bordes de las celdas de la tabla se mostrarán separados. */
.elemento-con-border-collapse-separate{ /**Se declara un selector por clase llamado "elemento-con-border-collapse-separate".**/
    border-collapse: separate; /**Se declara una propiedad de colapso de bordes con el valor "separate", ocacionando que los bordes de las celdas de la tabla se muestren separados.**/
} /**Se declara un selector por clase llamado "elemento-con-border-collapse-separate".**/

/* &Collapse */
/* &Declara un colapso de bordes colapsado, lo que significa que los bordes de las celdas de la tabla se mostrarán colapsados entre sí. (juntas) */
.elemento-con-border-collapse{ /**Se declara un selector por clase llamado "elemento-con-border-collapse".**/
    border-collapse: collapse; /**Se declara una propiedad de colapso de bordes con el valor "collapse", ocacionando que los bordes de las celdas de la tabla se muestren colapsados entre sí.**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Display & Visibility */
/* ~La propiedad `display{}` se utiliza para definir la forma en que se muestra un elemento HTML. Donde mediante valores podemos definir el comportamiento que se desea aplicar a un elemento podiendo forzar a un elemento en bloque a ser un elemento en linea, en bloque o ninguno ocacionando que el elemento no se muestre y no ocupe espacio (similar a como si no se ubiera declarado). Por otra parte visibility se utiliza para definir la visibilidad de un elemento HTML. Donde mediante valores podemos definir la visibilidad que se desea aplicar a un elemento, como visible o hidden. Esto significa que el elemento se mostrará o no se mostrará, pero ocupará espacio en la página. */
/* Todo - Display (display{}): La propiedad `display{}` se utiliza para definir la forma en que se muestra un elemento HTML. Donde mediante valores podemos definir el comportamiento que se desea aplicar a un elemento podiendo forzar a un elemento en bloque a ser un elemento en linea, en bloque o ninguno ocacionando que el elemento no se muestre y no ocupe espacio (similar a como si no se ubiera declarado). */
/* &Block */
/* &Declara un elemento en bloque, lo que significa que el elemento ocupará todo el ancho disponible y comenzará en una nueva línea. */
.elemento-con-display-inline{
    background-color: rgb(128, 255, 0); /**Se declara un color de fondo con el valor "rgb(128, 255, 0)", ocacionando que el fondo del elemento sea de color verde.**/
    display: inline; /**Se declara una propiedad de visualizacion con el valor "inline", ocacionando que el elemento ocupe solo el ancho necesario y no comience en una nueva linea.**/
}

/* &Inline */  
/* &Declara un elemento en linea, lo que significa que el elemento ocupará solo el ancho necesario y no comenzará en una nueva línea. */
.elemento-con-display-block{
    width: 17vw; /**Se declara un ancho con el valor "17vw", ocacionando que el elemento tenga un ancho de 15vw.**/
    height: 17vh; /**Se declara un ancho con el valor "17vw", ocacionando que el elemento tenga un ancho de 15vw.**/
    margin-top: 3vh; /**Se declara un margen superior con el valor "3vh", ocacionando que el elemento tenga un margen superior de 3vh.**/
    background-color: #ff009d; /**Se declara un color de fondo con el valor "rgb(255, 0, 157)", ocacionando que el fondo del elemento sea de color rosa.**/
    display: block; /**Se declara una propiedad de visualizacion con el valor "block", ocacionando que el elemento ocupe todo el ancho disponible y comience en una nueva linea.**/
    margin-bottom: 30px; /**Se declara un margen inferior con el valor "30px", ocacionando que el elemento tenga un margen inferior de 30px.**/
} /**Se declara una propiedad de visualizacion con el valor "block", ocacionando que el elemento ocupe todo el ancho disponible y comience en una nueva linea.**/

/* &Flex */
/* &Declara un elemento flexible, lo que significa que el elemento se comportará como un contenedor flexible y sus elementos secundarios se organizarán en una fila o columna. */
.elemento-con-display-flex{ /**Se declara un selector por clase llamado "elemento-con-display-flex".**/
    display: flex; /**Se declara una propiedad de visualizacion con el valor "flex", ocacionando que el elemento se comporte como un contenedor flexible y sus elementos secundarios se organicen en una fila o columna.**/
    background-color: #ff8f2d; /**Se declara un color de fondo con el valor "rgb(255, 143, 45)", ocacionando que el fondo del elemento sea de color naranja.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &None */
/* &Declara un elemento que no se mostrará y no ocupará espacio en la página. */
.elemento-con-display-none{ /**Se declara un selector por clase llamado "elemento-con-display-none".**/
    display: none; /**Se declara una propiedad de visualizacion con el valor "none", ocacionando que el elemento no se muestre y no ocupe espacio en la pagina.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Visibility (visibility{}): La propiedad `visibility{}` se utiliza para definir la visibilidad de un elemento HTML. Donde mediante valores podemos definir la visibilidad que se desea aplicar a un elemento, como visible o hidden. Esto significa que el elemento se mostrará o no se mostrará, pero ocupará espacio en la página. */
/* &Visible */
/* &Declara un elemento visible, lo que significa que el elemento se mostrará y ocupará espacio en la página. */
.elemento-con-visibility-visible{  
    width: 20vw; /**Se declara un ancho con el valor "20vw", ocacionando que el elemento tenga un ancho de 3vw.**/
    height: 20vh; /**Se declara un ancho con el valor "20vh", ocacionando que el elemento tenga un ancho de 3vh.**/
    background-color: #00bbff; /**Se declara un color de fondo con el valor "rgb(255, 119, 0)", ocacionando que el fondo del elemento sea de color naranja.**/ 
    visibility: visible; /**Se declara una propiedad de visibilidad con el valor "visible", ocacionando que el elemento se muestre y ocupe espacio en la pagina.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Hidden */
/* &Declara un elemento oculto, lo que significa que el elemento no se mostrará, pero ocupará espacio en la página. */
.elemento-con-visibility-hidden{ /**Se declara un selector por clase llamado "elemento-con-visibility-hidden".**/
    width: 20vw; /**Se declara un ancho con el valor "20vw", ocacionando que el elemento tenga un ancho de 3vw.**/
    height: 20vh; /**Se declara un ancho con el valor "20vh", ocacionando que el elemento tenga un ancho de 3vh.**/
    visibility: hidden; /**Se declara una propiedad de visibilidad con el valor "hidden", ocacionando que el elemento no se muestre, pero ocupe espacio en la pagina.**/
} 

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Position */
/* ~La propiedad de position se utiliza para definir la posición de un elemento HTML. Donde mediante valores podemos definir la posicion que se desea aplicar a un elemento, como static, relative, absolute, fixed o sticky. Esto significa que el elemento se posicionará de acuerdo a su flujo normal en el documento o se posicionará de acuerdo a su posición especificada. Podiendo ser relativo a su posición original, a su posición absoluta o a la ventana del navegador. */
/* Todo - Position (position{}): La propiedad `position{}` se utiliza para definir la posición de un elemento HTML. Donde mediante valores podemos definir la posicion que se desea aplicar a un elemento, como static, relative, absolute, fixed o sticky. Esto significa que el elemento se posicionará de acuerdo a su flujo normal en el documento o se posicionará de acuerdo a su posición especificada. Podiendo ser relativo a su posición original, a su posición absoluta o a la ventana del navegador. 
/* ^Posicion de elemento con position relative (top, right, bottom, left): La propiedad `top{}`, `right{}`, `bottom{}` y `left{}` se utilizan para definir la posición de un elemento HTML. Donde mediante cualquier unidad de medida podemos definir la posicion que se desea aplicar a un elemento con una posicion relativa, fixed o absolute, como por ejemplo si se desea mover el elemento hacia arriba, hacia la derecha, hacia abajo o hacia la izquierda. Esto significa que el elemento se moverá de acuerdo a su posición original en el documento. Cabe mencionar que las propiedades no moveran el elemento a dicha posicion, si no que generara un espacio en blanco en dicha ubicacion, un ejemplo de esto es que top no movera el elemento hacia arriba, si no que generara un espacio en blanco en la parte superior del elemento ocacionando que el elemento se mueva hacia abajo. Para el caso de position fixed es obligatorio declarar las propiedades top, right, bottom o left, ya que de lo contrario el elemento no se mostrara.
/* &Static */
/* &Declara una posición estática, lo que significa que el elemento se posicionará de acuerdo a su flujo normal en el documento. Este estilo es el valor por defecto de la propiedad. Ademas un elemento con posicion static no se puede mover con las propiedades top, right, bottom o left, ademas de que los elementos con position absolute no podran tomar como referencia de contenedor a un elemento con position static y por ultimo la propiedad z-index no tendra efecto en este tipo de elementos. */
.elemento-con-position-static{ /**Se declara un selector por clase llamado "elemento-con-position-static".**/
    border: 3px solid red; /**Se declara un borde con el valor "2px solid red", ocacionando que el elemento tenga un borde de 2px de grosor, solido y rojo.**/
    position: static; /**Se declara una propiedad de posicion con el valor "static", ocacionando que el elemento se posicione de acuerdo a su flujo normal en el documento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Relative */
/* &Declara una posición relativa, lo que significa que el elemento se posicionará de acuerdo a su posición original en el documento. El cual podra mover su ubicacion usando top, right, bottom o left, pero este generara un espacio en blanco en la parte donde este fue declarado. */
.elemento-con-position-relative{
    border: 1px solid blue; /**Se declara un borde con el valor "2px solid blue", ocacionando que el elemento tenga un borde de 2px de grosor, solido y azul.**/
    color: black; /**Se declara un color de texto con el valor "black", ocacionando que el texto del elemento sea negro */
    position: relative; /**Se declara una propiedad de posicion con el valor "relative".
    left: 30px; /**Se declara una propiedad de posicion con el valor "30px", ocacionando que el elemento se mueva 30px hacia la derecha.**/
    top: 30px; /**Se declara una propiedad de posicion con el valor "30px", ocacionando que el elemento se mueva 30px hacia abajo.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Fixed */
/* &Declara una posición fija, lo que significa que el elemento se posicionará de acuerdo a su posición absoluta en la ventana del navegador. Esto significa que el elemento no se moverá al hacer scroll en la página y se mantendrá en la misma posición. Por lo que fixed a comparacion de los demas positions, este no tomara su ubicacion base de donde fue declarada, por lo que no generara un campo o generara un espacio en blanco en la pagina. Ademas de que es obligatorio declarar las propiedades top, right, bottom o left, ya que de lo contrario el elemento no se mostrara. */
.elemento-con-position-fixed{ /**Se declara un selector por clase llamado "elemento-con-position-fixed".**/
    border: 3px solid rgb(153, 255, 0); /**Se declara un borde con el valor "2px solid rgb(153, 255, 0)", ocacionando que el elemento tenga un borde de 2px de grosor, solido y verde.**/
    position: static; /**Se declara una propiedad de posicion con el valor "fixed", ocacionando que el elemento se posicione de acuerdo a su flujo normal en el documento. El cual quedara pegado a la pantalla y sin generar un espacio en el documento al hacer scroll.**/
    /* !Se cambio el valor de la propiedad position de fixed a static, para que el elemento no se mantenga en la misma posicion al hacer scroll y afecte el diseño, contenido del curso.**/
    margin-top: 20px; /**Se declara un margen superior con el valor "20px", ocacionando que el elemento tenga un margen superior de 20px.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Absolute */
/* &Declara una posición absoluta, lo que significa que el elemento se posicionará de acuerdo a su posición absoluta en el documento. Esto significa que el elemento sera igual que el elemento de posicion relative, pero en este caso el elemento se posicionara de acuerdo a su posicion absoluta en el documento. Este a diferencia de fixed y relative, lo que hace es sobreponerse encima de los elementos pero sin que este este fijo en la ventana del navegador. Por lo que el elemento se movera al hacer scroll en la pagina quedandose donde fue declarado. Ademas a diferencia de relative no se generara un espacio en el documento, pese a si lo movemos con top, left, bottom o right. Adicionalmente cabe destacar que si se quiere que un elemento con posicion absolute tome de referencia a su contenedor padre, este debe de tener una posicion diferente a static, ya que de lo contrario tomara como referencia el documento. */
.elemento-con-position-absolute{ /**Se declara un selector por clase llamado "elemento-con-position-absolute".**/
    margin-top: 18px; /**Se declara un margen superior con el valor "18px", ocacionando que el elemento tenga un margen superior de 18px.**/
    color: black; /**Se declara un color de texto con el valor "black", ocacionando que el texto sea de color negro */
    border: 1px solid purple; /**Se declara un borde con el valor "1px solid purple", ocacionando que el elemento tenga un borde de 1px de grosor, solido y morado.**/
    position: absolute; /**Se declara una propiedad de posicion con el valor "absolute", ocacionando que el elemento se sobreponga al contenido, pero a diferencia de fix, este se mantendra donde se declare y admeas no genenrara un campo en blanco en el docuento**/
} /**Cierre de la declaracion de selector por clase**/

/* &Sticky */
/* &Declara una posición sticky, lo que significa que el elemento se posicionará de acuerdo a su posición relativa en el documento, pero se mantendrá fijo en la ventana del navegador cuando se alcance su posición de desplazamiento. Esto significa que el elemento al igual que la posicion relativa o estatica ocupara un espacio en el documento, ademas de que cuando se hace scroll hasta un punto que desaparece el elemento de la pantalla, este se quedara en el top de la pantalla, pero solo dentro de su contenedor padre. Ademas de que es obligatorio declarar las propiedades top ya que de lo contrario el elemento no se colocara en la parte superior de la pantalla al hacer scroll. */
.elemento-con-position-sticky{ /**Se declara un selector por clase llamado "elemento-con-position-sticky".**/
    top: 0; /**Se declara una propiedad de posicion con el valor "0", ocacionando que el elemento se mantenga en la parte superior de la pantalla.**/
    bottom: 10px; /**Se declara una propiedad de posicion con el valor "10px", ocacionando que el elemento se mantenga a 10px de la parte inferior de la pantalla.**/
    border: 1px solid orange; /**Se declara un borde con el valor "1px solid orange", ocacionando que el elemento tenga un borde de 1px de grosor, solido y naranja.**/
    position: sticky; /**Se declara una propiedad de posicion con el valor "sticky", ocacionando que el elemento se mantenga en la parte superior de la pantalla.**/
    color: black; /**Se declara un color de texto con el valor "black", ocacionando que el texto sea de color negro**/
} /**Cierre de la declaracion de selector por clase**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Z-Index */
/* ~La propiedad Z-Index se utiliza para definir la superposición de un elemento HTML en relación con otros elementos. Los valores más altos indican que el elemento estará más arriba en la pila de superposición, mientras que los valores más bajos indican que estará más abajo. Los valores pueden ser positivos, negativos o cero. Por lo que el valor por defecto es 0. Un ejemplo sería que se mostrará un elemento con un z-index de 1, por encima de otro elemento con un z-index de 0, y un elemento con un z-index de -1 se mostrará por debajo de un elemento con un z-index de 0. Cabe mencionar que para que z-index tenga efecto, el elemento debe tener una posición diferente a "static". */
.elemento-con-z-index-1{ /**Se declara un selector por clase llamado "elemento-con-z-index-1".**/
    z-index: 1; /**Se declara una propiedad de z-index con el valor "1", ocacionando que el elemento se muestre por encima de los elementos con un z-index menor.**/
    position: relative; /**Se declara una propiedad de posicion con el valor "relative", ocacionando que el elemento se posicione de acuerdo a su flujo normal en el documento.**/
    width: 20%;
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-z-index-menos-1{ /**Se declara un selector por clase llamado "elemento-con-z-index-menos-1".**/
    z-index: -1;  /**Se declara una propiedad de z-index con el valor "-1", ocacionando que el elemento se muestre por debajo de los elementos con un z-index mayor.**/
    position: relative;
    width: 20%;
}  /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Overflow */
/* ~La propiedad overflow se utiliza para definir cómo se manejará el contenido que desborda el área de un elemento. Esto significa que si el contenido de un elemento es más grande que el área del elemento, se puede ocultar, mostrar una barra de desplazamiento o mostrar el contenido desbordado. Los valores pueden ser visible, hidden, scroll o auto. */
/* &Visible */
/* &Declara un desbordamiento visible, lo que significa que el contenido al no caber dentro del elemento si se han especificado en este ciertas dimenciones, se mostrará fuera del área del elemento. Este es el valor por defecto de la propiedad. */
.elemento-con-overflow-visible{ /**Se declara un selector por clase llamado "elemento-con-overflow-visible".**/
    overflow: visible; 
    width: 20%; /**Se declara un ancho con el valor "20%", ocacionando que el elemento tenga un ancho de 20%.**/
    height: 19vh; /**Se declara un alto con el valor "18vh", ocacionando que el elemento tenga un alto de 19vh.**/
    background-color: rgb(255, 247, 0); /***Se declara un color de fondo con el valor "rgb(255, 247, 0)", ocacionando que el fondo del elemento sea de color amarillo.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Hidden */
/* &Declara un desbordamiento oculto, lo que significa que el contenido al no caber dentro del elemento si se han especificado en este ciertas dimenciones, se ocultará y no se mostrará fuera del área del elemento, pero no permitira visualizar dicho contenido no mostrado */
.elemento-con-overflow-hidden{
    overflow: hidden; /**Se declara una propiedad de desbordamiento con el valor "hidden", ocacionando que el contenido que no quepa dentro del elemento se ocultara y no se mostrara fuera del area del elemento.**/
    position: absolute; /**Se declara una propiedad de posicion con el valor "absolute", ocacionando que el elemento se sobreponga al contenido, pero a diferencia de fix, este se mantendra donde se declare y ademas no generara un campo en blanco en el docuento**/
    background-color: #007bff; /**Se declara un color de fondo con el valor "rgb(0, 123, 255)", ocacionando que el fondo del elemento sea de color azul.**/
    top: 0px; /**Se declara una propiedad de posicion con el valor "0px", ocacionando que el elemento se mantenga en la parte superior de la pantalla.**/
    left: 25%; /**Se declara una propiedad de posicion con el valor "25%", ocacionando que el elemento se mantenga a 25% de la parte izquierda de la pantalla.**/
    width: 20%; /**Se declara un ancho con el valor "20%", ocacionando que el elemento tenga un ancho de 20%.**/
    height: 19vh; /**Se declara un alto con el valor "110px", ocacionando que el elemento tenga un alto de 19vh.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Scroll */
/* &Declara un desbordamiento con barra de desplazamiento, lo que significa que el contenido al no caber dentro del elemento si se han especificado en este ciertas dimenciones, se mostrará una barra de desplazamiento para permitir ver el contenido desbordado. */
.elemento-con-overflow-scroll{
    overflow: scroll; /**Se declara una propiedad de desbordamiento con el valor "scroll", ocacionando que el contenido que no quepa dentro del elemento se mostrara una barra de desplazamiento para permitir ver el contenido desbordado.**/
    position: absolute; /**Se declara una propiedad de posicion con el valor "absolute", ocacionando que el elemento se sobreponga al  contenido, pero a diferencia de fix, este se mantendra donde se declare y ademas no generara un campo en blanco en el docuento**/
    top: 0; /**Se declara una propiedad de posicion con el valor "0", ocacionando que el elemento se mantenga en la parte superior de la pantalla.**/
    left: 50%; /**Se declara una propiedad de posicion con el valor "50%", ocacionando que el elemento se mantenga a 50% de la parte izquierda de la pantalla.**/
    background-color: #e880ff; /**Se declara un color de fondo con el valor "rgb(232, 128, 255)", ocacionando que el fondo del elemento sea de color morado.**/
    width: 20%; /**Se declara un ancho con el valor "20%", ocacionando que el elemento tenga un ancho de 20%.**/
    height: 21vh; /**Se declara un alto con el valor "21vh", ocacionando que el elemento tenga un alto de 21vh.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Ocultar barra de scroll (overflow-x{} y overflow-y{}): La propiedad `overflow-x{}` y `overflow-y{}` se utilizan para definir cómo se manejará el contenido que desborda el área de un elemento en el eje X o Y respectivamente. Esto significa que si el contenido de un elemento es más grande que el área del elemento, se puede ocultir, mostrar una barra de desplazamiento o mostrar el contenido desbordado. Los valores pueden ser visible, hidden, scroll o auto. */
.elemento-con-overflow-x-hidden{ /**Se declara un selector por clase llamado "elemento-con-overflow-x-hidden".**/
    overflow: scroll; /**Se declara una propiedad de desbordamiento con el valor "scroll", ocacionando que el contenido que no quepa dentro del elemento se mostrara una barra de desplazamiento para permitir ver el contenido desbordado.**/
    overflow-x: hidden; /**Se declara una propiedad de desbordamiento con el valor "hidden", ocacionando que el contenido que no quepa dentro del elemento se ocultara y no se mostrara fuera del area del elemento.**/
    position: absolute; /**Se declara una propiedad de posicion con el valor "absolute", ocacionando que el elemento se sobreponga al contenido, pero a diferencia de fix, este se mantendra donde se declare y ademas no generara un campo en blanco en el docuento**/
    top: 0; /**Se declara una propiedad de posicion con el valor "0", ocacionando que el elemento se mantenga en la parte superior de la pantalla.**/
    left: 75%; /**Se declara una propiedad de posicion con el valor "75%", ocacionando que el elemento se mantenga a 75% de la parte izquierda de la pantalla.**/
    background-color: #8bff80; 
    width: 20%; /**Se declara un ancho con el valor "20%", ocacionando que el elemento tenga un ancho de 20%.**/
    height: 19vh; /**Se declara un alto con el valor "21vh", ocacionando que el elemento tenga un alto de 21vh.**/
} /**Cierre de la declaracion de selector por clase.**/

.elemento-con-overflow-y-hidden{
    overflow: scroll; /**Se declara una propiedad de desbordamiento con el valor "scroll", ocacionando que el contenido que no quepa dentro del elemento se mostrara una barra de desplazamiento para permitir ver el contenido desbordado.**/
    overflow-y: hidden; /**Se declara una propiedad de desbordamiento con el valor "hidden", ocacionando que el contenido que no quepa dentro del elemento se ocultara y no se mostrara fuera del area del elemento.**/
    position: relative; /**Se declara una propiedad de posicion con el valor "absolute", ocacionando que el elemento se sobreponga al contenido, pero a diferencia de fix, este se mantendra donde se declare y ademas no generara un campo en blanco en el docuento**/
    background-color: #8bff80; 
    margin-top: 70px; /**Se declara un margen superior con el valor "70px", ocacionando que el elemento tenga un margen superior de 70px.**/
    width: 20%; /**Se declara un ancho con el valor "20%", ocacionando que el elemento tenga un ancho de 20%.**/
    height: 21vh; /**Se declara un alto con el valor "21vh", ocacionando que el elemento tenga un alto de 21vh.**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Float */
/* ~La propiedad float se utiliza para posicionar un elemento a la izquierda o derecha de su contenedor (left, right), permitiendo que el texto y otros elementos fluyan alrededor de él. Esto significa que los elementos con la propiedad de float hace que los elementos fluyan alrededor de ellos, permitiendo que el texto y otros elementos se coloquen a su alrededor. Los valores pueden ser left, right, none o inherit. */
/* &Left */
/* &Declara un elemento flotante a la izquierda, lo que significa que el elemento se posicionará a la izquierda de su contenedor y el texto y otros elementos fluirán alrededor de él. */
.elemento-con-float-left{ /**Se declara un selector por clase llamado "elemento-con-float-left".**/
    float: left; /**Se declara una propiedad de flotacion con el valor "left", ocacionando que el elemento se posicione a la izquierda de su contenedor.**/
    width: 300px; /**Se declara un ancho con el valor "300px", ocacionando que el elemento tenga un ancho de 300px.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Right */
/* &Declara un elemento flotante a la derecha, lo que significa que el elemento se posicionará a la derecha de su contenedor y el texto y otros elementos fluirán alrededor de él. */
.elemento-con-float-right{ /**Se declara un selector por clase llamado "elemento-con-float-right".**/
    float: right; /**Se declara una propiedad de flotacion con el valor "right", ocacionando que el elemento se posicione a la derecha de su contenedor.**/
    width: 300px; /**Se declara un ancho con el valor "300px", ocacionando que el elemento tenga un ancho de 300px.**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Selectores Combinados */
/* ~Los selectores combinados se utilizan para seleccionar elementos HTML en función de su relación con otros elementos. Esto significa que los selectores combinados permiten seleccionar elementos en función de su jerarquía o relación con otros elementos. Los selectores combinados pueden ser descendientes, hijos, hermanos adyacentes o hermanos generales. */
/* &Descendientes */
/* &Declara un selector combinado descendiente, lo que significa que selecciona todos los elementos que son descendientes de un elemento padre. Ya que se especifica un elemento ya sea por etiqueta, clase o id, seguido de un espacio y el elemento descendiente. Quedan definidos como descendientes todos los elementos que se encuentran dentro del elemento padre teniendo como ejemplo que un elemento padre es un div y dentro de este se encuentran varios elementos como p, h1, h2, etc. Si se define un selector combinado descendiente como div p, se seleccionaran todos los elementos p que se encuentren dentro del elemento div sin importar cuántos niveles de anidación haya entre ellos o si estos se encuentran dentro de otros elementos que no sean en el elemento padre raiz. Por lo que para definir un selector combinado descendiente se utiliza el espacio entre el elemento padre y el elemento descendiente. */
.elemento-con-selector-combinado-descendiente p{ /**Se declara un selector combinado descendiente, lo que significa que selecciona todos los elementos que son descendientes de un elemento padre.**/
    background-color: rgb(255, 255, 255); /**Se declara un color de fondo con el valor "rgb(255, 255, 255)", ocacionando que el fondo del elemento sea de color blanco.**/
} /**Cierre de la declaracion de selector combinado descendiente.**/

/* &Hijos */
/* &Declara un selector combinado hijo, lo que significa que selecciona todos los elementos que son hijos directos de un elemento padre. Ya que se especifica un elemento ya sea por etiqueta, clase o id, seguido de un espacio y el elemento hijo. Quedan definidos como hijos todos los elementos que se encuentran dentro del elemento padre teniendo como ejemplo que un elemento padre es un div y dentro de este se encuentran varios elementos como p, h1, h2, etc. Si se define un selector combinado hijo como div > p, se seleccionaran todos los elementos p que sean hijos directos del elemento div sin importar cuántos niveles de anidación haya entre ellos o si estos se encuentran dentro de otros elementos que no sean en el elemento padre raiz. Por lo que para definir un selector combinado hijo se utiliza el simbolo mayor entre el elemento padre y el elemento hijo. */
.elemento-con-selector-combinado-hijo>p{  /**Se declara un selector combinado hijo, lo que significa que selecciona todos los elementos que son hijos directos de un elemento padre.**/
    background-color: rgb(255, 255, 255); /**Se declara un color de fondo con el valor "rgb(255, 255, 255)", ocacionando que el fondo del elemento sea de color blanco.**/
} /**Cierre de la declaracion de selector combinado hijo.**/

/* &Hermanos adyacentes */
/* &Declara un selector combinado hermano adyacente, lo que significa que selecciona todos los elementos que son hermanos adyacentes de un elemento. Ya que se especifica un elemento ya sea por etiqueta, clase o id, seguido de un espacio y el elemento hermano adyacente. Quedan definidos como hermanos adyacentes todos los elementos que se encuentran dentro del mismo elemento padre que el elemento con la clase de hermano adyacente. Si se define un selector combinado hermano adyacente como div + p, se seleccionaran todos los elementos p que encuentre en el codigo en la parte inferior del elemento div, cabe resaltar que solamente se seleccionara el primer elemento p que encuentre en el codigo. Por lo que para definir un selector combinado hermano adyacente se utiliza el simbolo de suma entre el elemento padre y el elemento hermano adyacente. En resumen podemos decir que un selector combinado hermano adyacente selecciona el primer elemento que se encuentra despues del elemento con la clase de hermano adyacente en el codigo, ademas de solo deleccionar el primer elemento dentro del mismo elemento padre que el elemento con la clase de hermano adyacente. */
.elemento-con-selector-combinado-hermano-adyacente+p{ /**Se declara un selector combinado hermano adyacente, lo que significa que selecciona todos los elementos que son hermanos adyacentes de un elemento.**/
    background-color: rgb(255, 255, 255); /**Se declara un color de fondo con el valor "rgb(255, 255, 255)", ocacionando que el fondo del elemento sea de color blanco.**/
} /**Cierre de la declaracion de selector combinado hermano adyacente.**/

/* &Hermanos generales */
/* &Declara un selector combinado hermano general, lo que significa que selecciona todos los elementos que son hermanos generales de un elemento. Ya que se especifica un elemento ya sea por etiqueta, clase o id, seguido de un espacio y el elemento hermano general. Quedan definidos como hermanos generales todos los elementos que se encuentran dentro del mismo elemento padre que el elemento con la clase de hermano general. Si se define un selector combinado hermano general como div ~ p, se seleccionaran todos los elementos p que encuentre en el codigo en la parte inferior del elemento div, cabe resaltar que a diferencia del hermano adyacente aqui se seleccionaran todos los elementos p que encuentre en el codigo dentro del mismo elemento padre que el elemento con la clase de hermano general y debajo de este. Por lo que para definir un selector combinado hermano general se utiliza el simbolo de tilde entre el elemento padre y el elemento hermano general. En resumen podemos decir que un selector combinado hermano general selecciona todos los elementos que se encuentran despues del elemento con la clase de hermano general en el codigo, ademas de solo deleccionar los elementos dentro del mismo elemento padre que el elemento con la clase de hermano general. */
.elemento-con-selector-combinado-hermanos-generales~p{ /**Se declara un selector combinado hermano general, lo que significa que selecciona todos los elementos que son hermanos generales de un elemento.**/
    background-color: rgb(255, 255, 255); /**Se declara un color de fondo con el valor "rgb(255, 255, 255)", ocacionando que el fondo del elemento sea de color blanco.**/
} /**Cierre de la declaracion de selector combinado hermano general.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Pseudoclases */
/* ~Las pseudoclases son aquellas que al realizar cierto tipo de accion en el elemento, este se comportar distinto. Por lo que podemos decir que las pseudoclases son palabras clave que se añaden a un selector para especificar un estado especial del elemento seleccionado. Esto significa que las pseudoclases permiten seleccionar elementos en función de su estado o posición en el documento. Las pseudoclases pueden ser hover, active, focus, visited, checked, entre otras. Lo que hace que los elementos por ejemplo cambien de color, tamaño o forma al pasar el mouse sobre ellos, al hacer clic en ellos o al recibir el foco (recibir foco significa que el elemento es seleccionado por el usuario, por ejemplo al hacer clic en un campo de formulario o al navegar a través de los elementos de la página con el teclado). */
/* Todo - Declaración de pseudoclases: Para poder declarar una pseudoclase se utiliza el simbolo de dos puntos seguido del nombre de la pseudoclase. quedando la estructura como elemento:seudoelemento{propiedad:valor;}. Por ende para declarar una pseudoclase se ingresa el nombre del elemento, clase o id seguido de dos puntos y el nombre de la pseudoclase la cual se desea aplicar, seguido de llaves donde se declaran las propiedades y valores que se desean aplicar al elemento. Dichos valores a declarar dentro seran los que se aplicaran al elemento cuando este cumpla con la condicion de la pseudoclase. */
.declaracion-pseudoclase:hover{ /**Se declara un selector por clase llamado "declaracion-pseudoclase", donde ademas se le aplica una pseudoclase llamada "hover", la cual se activara cuando el mouse pase por encima del elemento.**/
    background-color: #ff8f2d; /**Se declara un color de fondo con el valor "rgb(255, 143, 45)", ocacionando que el fondo del elemento sea de color naranja al pasar el mouse por encima del elemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Link */
/* &Declara una pseudoclase de enlace, lo que significa que las propiedades declaradas en la pseudoclase se aplicaran unicamente cuando el elemento es un enlace. */
.elemento-con-pseudoclase-link:link{ /**Se declara un selector por clase llamado "elemento-con-pseudoclase-link", donde ademas se le aplica una pseudoclase llamada "hover", la cual se activara cuando el mouse pase por encima del elemento.**/
    background-color: rgb(147, 255, 255); /**Se declara un color de fondo con el valor "rgb(255, 143, 45)", ocacionando que el fondo del elemento sea de color naranja solo si el elemento es un enlace.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Visited */
/* &Declara una pseudoclase de enlace visitado, lo que significa que las propiedades declaradas en la pseudoclase se aplicaran unicamente cuando el elemento es un enlace y este ya ha sido visitado. Cabe destacar que por seguridad hay muy pocas propiedades que se pueden aplicar a un enlace visitado, como lo son color, outline-color, border-color, etc.. */
.elemento-con-pseudoclase-visited:visited{ /**Se declara un selector por clase llamado "elemento-con-pseudoclase-visited", donde ademas se le aplica una pseudoclase llamada "visited", la cual se activara cuando el elemento sea un enlace y este ya ha sido visitado.**/
    color: rgb(35, 162, 0); /**Se declara un color de fondo con el valor "firebrick", ocacionando que el fondo del elemento sea de color rojo solo si el elemento es un enlace y este ya ha sido visitado.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Hover */
/* &Declara una pseudoclase de paso del mouse, lo que significa que las propiedades declaradas en la pseudoclase se aplicaran unicamente cuando el mouse pase por encima del elemento. Asi mismo hay que mencionar que la pseudoclase hoverpuede cambiar una condicion de otro elemento, un ejemplo de esto es que si un elemento externo al que tiene la pseudoclase con el hover, cuenta con un border azul, se puede declarar en la pseudoclase hover que el border de ese elemento externo cambie a uno diferente. Ocacionando que al hacer jover en un elemento otro completamente diferente tenga un cambio. */
.elemento-con-pseudoclase-hover:hover{ /**Se declara un selector por clase llamado "elemento-con-pseudoclase-hover", donde ademas se le aplica una pseudoclase llamada "hover", la cual se activara cuando el mouse pase por encima del elemento.**/
    background-color: rgb(248, 147, 255); /**Se declara un color de fondo con el valor "rgb(248, 147, 255)", ocacionando que el fondo del elemento sea de color morado al pasar el mouse por encima del elemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Active */
/* &Declara una pseudoclase de elemento activo, lo que significa que las propiedades declaradas en la pseudoclase se aplicaran unicamente cuando se clickee sobre el elemento o se haga doble clic en el elemento manteniendo el clic. Esto significa que el elemento se mantendrá activo hasta que se suelte el clic. */
.elemento-con-pseudoclase-active:active{ /**Se declara un selector por clase llamado "elemento-con-pseudoclase-active", donde ademas se le aplica una pseudoclase llamada "active", la cual se activara cuando el elemento sea un enlace y este ya ha sido visitado.**/
    background-color: rgb(255, 238, 88); /**Se declara un color de fondo con el valor "rgb(255, 238, 88)", ocacionando que el fondo del elemento sea de color amarillo al pasar el mouse por encima del elemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &First-child */
/* &Declara una pseudoclase de primer hijo, lo que significa que las propiedades declaradas en la pseudoclase se aplicaran unicamente al primer hijo del elemento padre. Esto significa que esta pseudoclase se debe definir en un elemento que sea hijo de otro elemento, ya que si no es asi no se aplicara la pseudoclase, ya que esta pseudoclase no entra en el elemento y busca el primer hijo, si no que la pseudoclase evalua si el elemento es el primer hijo del elemento padre. */
.elemento-con-pseudoclase-first-child:first-child{ /**Se declara un selector por clase llamado "elemento-con-pseudoclase-first-child", donde ademas se le aplica una pseudoclase llamada "first-child", la cual se activara cuando el elemento sea el primer hijo del elemento padre.**/
    background-color: rgb(255, 98, 98); /**Se declara un color de fondo con el valor "rgb(255, 0, 0)", ocacionando que el fondo del elemento sea de color rojo al pasar el mouse por encima del elemento.**/
    margin-bottom: 3px; /**Se declara un margen inferior con el valor "3px", ocacionando que el elemento tenga un margen inferior de 3px.**/
    border: 1px solid black; /**Se declara un borde con el valor "1px solid black", ocacionando que el elemento tenga un borde de 1px de grosor, solido.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Last-child */
/* &Declara una pseudoclase de ultimo hijo, lo que significa que las propiedades declaradas en la pseudoclase se aplicaran unicamente al ultimo hijo del elemento padre. Esto significa que esta pseudoclase se debe definir en un elemento que sea hijo de otro elemento, ya que si no es asi no se aplicara la pseudoclase, ya que esta pseudoclase no entra en el elemento y busca al ultimo hijo, si no que la pseudoclase evalua si el elemento es el ultimo hijo del elemento padre. */
.elemento-con-pseudoclase-last-child:last-child{ /**Se declara un selector por clase llamado "elemento-con-pseudoclase-last-child:last-child" **/
    background-color: rgb(133, 255, 149); /**Se declara un color de fondo con el valor "rgb(133, 255, 149)", ocasionando que el fondo del elemento sea de color verde claro cuando sea el último hijo.**/
} /**Cierre de la declaracion de selector por clase**/

/* &Nth-child */
/* &Declara una pseudoclase de hijo en la posicion n, lo que significa que las propiedades declaradas en la pseudoclase se aplicaran unicamente al hijo en la posicion n del elemento padre. Esto significa que esta pseudoclase se debe definir en un elemento que sea hijo de otro elemento, ya que si no es asi no se aplicara la pseudoclase, ya que esta pseudoclase no entra en el elemento y busca al hijo en la posicion n, si no que la pseudoclase evalua si el elemento es el hijo en la posicion n del elemento padre. Por lo que al mencionar la posicion n se debe a que dentro de esta pseudoclase se puede definir hijos en posiciones pares, impares o especificas, ocacionando que se seleccionen los elementos que se encuentren en esas posiciones siempre y cuando estos sean hijos de un elemento padre y tengan la pseudoclase definida. */
/* Todo - Declaración de nth-child de hijos en posiciones pares (even): Para poder declarar una pseudoclase nth-child de hijos en posiciones pares se utiliza el simbolo de dos puntos seguido del nombre de la pseudoclase nth-child y dentro de parentesis se define el valor de la posicion n. quedando la estructura como elemento:nth-child(n){propiedad:valor;}. Por ende para declarar una pseudoclase nth-child de hijos en posiciones pares se ingresa el nombre del elemento, clase o id seguido de dos puntos y el nombre de la pseudoclase nth-child, seguido de parentesis donde se declara el valor de la posicion n. Por lo que dicho valor a declarar dentro de los parentesis para hijos pares sera el valor "even". */
.elemento-con-pseudoclase-nth-child-even:nth-child(even){ /**Se declara un selector por clase llamado "elemento-con-pseudoclase-nth-child-even" con la pseudoclase "nth-child(even)", aplicando estilos a los hijos en posiciones pares.**/
    background-color: #007bff; /**Se declara un color de fondo con el valor hexadecimal "#007bff".**/
    margin: 5px 0; /**Se declara una propiedad de margen con el valor "5px 0", ocasionando que el elemento tenga un margen de 5px arriba y abajo, y 0 a los lados.**/
} /**Cierre de la declaracion de selector por clase**/

/* Todo - Declaración de nth-child de hijos en posiciones impares (odd): Para poder declarar una pseudoclase nth-child de hijos en posiciones impares se utiliza el símbolo de dos puntos seguido del nombre de la pseudoclase nth-child y dentro de paréntesis se define el valor de la posición n, quedando la estructura como elemento:nth-child(n){propiedad:valor;}. Por ende, para declarar una pseudoclase nth-child de hijos en posiciones impares se ingresa el nombre del elemento, clase o id seguido de dos puntos y el nombre de la pseudoclase nth-child, seguido de paréntesis donde se declara el valor de la posición n. El valor a declarar dentro de los paréntesis para hijos impares será "odd". */
.elemento-con-pseudoclase-nth-child-odd:nth-child(odd){ /**Se declara un selector por clase llamado "elemento-con-pseudoclase-nth-child-odd" con la pseudoclase "nth-child(odd)", aplicando estilos a los hijos en posiciones impares**/
    background-color: rgb(251, 255, 4); /**Se declara un color de fondo con el valor RGB "251, 255, 4".**/
    margin: 5px 0;  /**Se declara una propiedad de margen con el valor "5px 0", ocasionando que el elemento tenga un margen de 5px arriba y abajo, y 0 a los lados.**/
} /**Cierre de la declaracion de selector por clase**/

/* &Focus */
/* &Declara una pseudoclase de foco, la cual aplica estilos solo cuando un elemento recibe el foco. Esto ocurre, por ejemplo, al hacer clic sobre un input o al llegar a él usando el teclado (como con la tecla Tab). Esto significa que los estilos definidos dentro de :focus se activan solo cuando el usuario está interactuando con el elemento. */
.elemento-con-pseudoclase-focus:focus{ /**Se declara un selector por clase llamado "elemento-con-pseudoclase-focus", donde ademas se le aplica una pseudoclase llamada "focus", la cual se activara cuando el elemento sea un input y se seleccione.**/
    background-color: rgb(255, 187, 187);  /**Se declara un color de fondo con el valor RGB "255, 187, 187".**/
} /**Cierre de la declaracion de selector por clase**/

/* &Negación (:not()) */
/* &Declara una pseudoclase de negación, lo que significa que las propiedades declaradas se aplicarán a todos los elementos, excepto a los que coincidan con el selector especificado dentro de la pseudoclase. Esto significa que la pseudoclase :not() permite excluir ciertos elementos de un grupo al que se le quiere aplicar un estilo. Por ejemplo, si se desea aplicar un estilo a todos los elementos excepto a los enlaces, se puede usar :not(a). También se puede combinar con otras pseudoclases, por ejemplo, si se quiere aplicar un efecto hover a todos los elementos "li" de la página web, pero excluir aquellos que tengan la clase "no-hover", se puede declarar el selector como "li:not(.no-hover):hover". Esto significa que el estilo se aplicará al pasar el mouse sobre todos los "li", excepto a los que tengan la clase "no-hover". Cabe mencionar que esta pseudoclase no entra en las etiquetas si no que valida que el elemento con la pseudoclase no sea el elemento, clase  o id especificado dentro del not(). */
.elemento-con-pseudoclase-not-hover li:not(.denegado):hover{  /**Se declara un selector por clase llamado "elemento-con-pseudoclase-not-hover", donde ademas se le aplica una pseudoclase llamada "not", la cual se activara cuando el elemento sea un li y no tenga la clase "denegado" al pasar el mouse por encima del elemento.**/
    background-color: rgb(29, 52, 255);  /**Se declara un color de fondo con el valor RGB "64, 0, 255", ocacionando que el fondo del elemento sea de color morado al pasar el mouse por encima del elemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Pseudoelementos */
/* ~Los pseudoelementos son una forma de seleccionar y aplicar estilos a partes específicas de un elemento. Esto significa que los pseudoelementos permiten seleccionar y aplicar estilos a partes específicas de un elemento, como la primera letra o la primera línea de un párrafo. Los pseudoelementos pueden ser first-letter, first-line, before, after, entre otros. Esto significa que los pseudoelementos permiten aplicar estilos a partes específicas dentro de un elemento, como la primera letra o la primera línea de un párrafo. */
/* Todo - Declaración de pseudoelementos: La forma de declarar un pseudoelemento es similar a la de una pseudoclase, pero en lugar de usar el símbolo de dos puntos (:) se utiliza dos puntos dobles (::), seguido del nombre del pseudoelemento. quedando la estructura como elemento:seudoelemento{propiedad:valor;}. Por ende para declarar un pseudoelemento se ingresa el nombre del elemento, clase o id seguido de dos puntos y el nombre del pseudoelemento el cual se desea aplicar, seguido de llaves donde se declaran las propiedades y valores que se desean aplicar al elemento. Dichos valores a declarar dentro seran los que se aplicaran al elemento cuando este cumpla con la condicion de la pseudoclase. Adicionalmente hay que mencionar que se pueden especificar pseudoelementos sin una clase, etiqueta, id o selector, lo que significa que se aplicara el pseudoelemento a todos los elementos de la pagina web, para esto se debe declarar el pseudoelemento sin un selector, etiqueta o id, por ejemplo "::first-letter" se aplicara a todos los elementos de la pagina web que tengan texto, donde la primera letra de cada etiqueta, contenedor o elemento de la pagina web tendra el estilo definido dentro del pseudoelemento. */
.declaracion-pseudoelemento:first-letter{ /**Se declara un selector por clase llamado "declaracion-pseudoelemento", donde ademas se le aplica un pseudoelemento llamado "first-letter", el cual se aplicara un estilo a la primera letra del elemento.**/
    background-color: #ff8f2d; /**Se declara un color de fondo con el valor "rgb(255, 143, 45)", ocacionando que el fondo de la primera letra del elemento sea de color naranja, debido a el pseudoelemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &First-line */
/* &Declara un pseudoelemento de primera línea, lo que significa que las propiedades declaradas en el pseudoelemento se aplicaran unicamente a la primera línea del elemento. Esto significa que este pseudoelemento se debe definir en un elemento que tenga texto, ya que si no es asi no se aplicara el pseudoelemento, en este caso el pseudoelemento entra en el elemento y busca la primera línea de texto, aplicando los estilos definidos dentro del pseudoelemento. Cabe mencionar que se tomara la primera linea de la pagina web, mas no la declarada en el codigo html, por lo quue el tamaño de la primera linea dependera del tamaño de la pantalla y el tamaño de la fuente. */
.elemento-con-pseudoelemento-first-line::first-line{ /**Se declara un selector por clase llamado "elemento-con-pseudoelemento-first-line", donde ademas se le aplica un pseudoelemento llamado "first-line", el cual se aplicara un estilo a la primera línea del elemento.**/
    background-color: red; /**Se declara un color de fondo con el valor "red", ocacionando que el fondo de la primera línea del elemento sea de color rojo, debido a el pseudoelemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &First-letter */
/* &Declara un pseudoelemento de primera letra, lo que significa que las propiedades declaradas en el pseudoelemento se aplicaran unicamente a la primera letra del elemento. Esto significa que este pseudoelemento se debe definir en un elemento que tenga texto, ya que si no es asi no se aplicara el pseudoelemento, en este caso el pseudoelemento entra en el elemento y busca la primera letra de texto, aplicando los estilos definidos dentro del pseudoelemento. Cabe mencionar que se tomara la primera letra de la pagina web, mas no la declarada en el codigo html. Adicionalmente hay que destacar que si antes de la primera letra se encuentra un espacio, simbolo o cualquier otro elemento, a estos se les aplicara el pseudoelemento y se detendra en el primer caracter que no sea un espacio, simbolo o cualquier otro elemento. */
.elemento-con-pseudoelemento-first-letter::first-letter{ /**Se declara un selector por clase llamado "elemento-con-pseudoelemento-first-letter", donde ademas se le aplica un pseudoelemento llamado "first-letter", el cual se aplicara un estilo a la primera letra del elemento.**/
    color: orange; /**Se declara un color de texto con el valor "orange", ocacionando que el color de la primera letra del elemento sea de color naranja, debido a el pseudoelemento.**/
    font-size: 2rem; /**Se declara un tamaño de fuente con el valor "2rem", ocacionando que el tamaño de la primera letra del elemento sea de 2rem, debido a el pseudoelemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Before */
/* &El pseudoelemento de before se utiliza para insertar contenido antes del contenido real de un elemento, por lo que el pseudoelemento before permite agregar contenido antes del contenido dentro del elemento con el pseudoelemento. Esto significa que el pseudoelemento before se utiliza para agregar unicamente contenido como lo son texto, imagenes, con CSS, y dicho contenido se mostrara antes del contenido real del elemento. Cabe mencionar que el elemento after para ser mostrado se debera especificar como minimo un "conten: ''" */
.elemento-con-pseudoelemento-before::before{ /**Se declara un selector por clase llamado "elemento-con-pseudoelemento-before", donde ademas se le aplica un pseudoelemento llamado "before", el cual se aplicara un estilo antes del elemento.**/
    content: url(../assets/icons/Music_Icon.png); /**Se declara un contenido con el valor "url(../assets/icons/Music_Icon.png)", ocacionando que el contenido del elemento sea una imagen de un icono de musica, debido a el pseudoelemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &After */
/* &El pseudoelemento de after se utiliza para insertar contenido despues del contenido real de un elemento, por lo que el pseudoelemento after permite agregar contenido despues del contenido dentro del elemento con el pseudoelemento. Esto significa que el pseudoelemento after se utiliza para agregar unicamente contenido como lo son texto, imagenes, con CSS, y dicho contenido se mostrara despues del contenido real del elemento. Cabe mencionar que el contenido que se declare dentro del pseudoelemento after se mostrara dentro del elemento con el pseudoelemento, recorriendo al demas contenido. Cabe mencionar que el elemento after para ser mostrado se debera especificar como minimo un "conten: ''" */
.elemento-con-pseudoelemento-after::after{ /**Se declara un selector por clase llamado "elemento-con-pseudoelemento-after", donde ademas se le aplica un pseudoelemento llamado "after", el cual se aplicara un estilo despues del elemento.**/
    content: url(../assets/icons/Music_Icon.png); /**Se declara un contenido con el valor "url(../assets/icons/Music_Icon.png)", ocacionando que el contenido del elemento sea una imagen de un icono de musica, debido a el pseudoelemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Marker*/ 
/* &El pseudoelemento de marker se utiliza para seleccionar el marcador de un elemento, lo que significa que las propiedades declaradas en el pseudoelemento se aplicaran unicamente al marcador del elemento. Esto significa que este pseudoelemento se debe definir en un elemento que tenga un marcador, ya que si no es asi no se aplicara el pseudoelemento. */
.elemento-con-pseudoelemento-marker::marker{ /**Se declara un selector por clase llamado "elemento-con-pseudoelemento-marker", donde ademas se le aplica un pseudoelemento llamado "marker", el cual se aplicara un estilo al marcador del elemento.**/
    color: rgb(34, 0, 255); /**Se declara un color de texto con el valor "rgb(34, 0, 255)", ocacionando que el color del marcador del elemento sea de color azul, debido a el pseudoelemento.**/
    font-size: 25px; /**Se declara un tamaño de fuente con el valor "25px", ocacionando que el tamaño del marcador del elemento sea de 25px, debido a el pseudoelemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/* &Selection */
/* &El pseudoelemento de selection se utiliza para seleccionar el texto seleccionado dentro de un elemento, lo que significa que las propiedades declaradas en el pseudoelemento se aplicaran unicamente al texto seleccionado dentro del elemento. Esto significa que este pseudoelemento se debe definir en un elemento que tenga texto, ya que si no es asi no se aplicara el pseudoelemento, donde las propiedades se veran reflejados en el texto cuando este se seleccione ya sea dando doble click y mantenido el click mientras se arrastra el mouse para seleccionar el texto. */
.elemento-con-pseudoelemento-selection::selection{ /**Se declara un selector por clase llamado "elemento-con-pseudoelemento-selection", donde ademas se le aplica un pseudoelemento llamado "selection", el cual se aplicara un estilo al texto seleccionado dentro del elemento.**/
    background-color: rgb(94, 255, 0); /**Se declara un color de fondo con el valor "rgb(94, 255, 0)", ocacionando que el fondo del texto seleccionado dentro del elemento sea de color verde claro, debido a el pseudoelemento.**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Opacidad */
/* ~La propiedad de opacidad se utiliza para establecer la transparencia de un elemento, donde el valor de opacidad puede variar entre 0 (completamente transparente) y 1 (completamente opaco). Esto significa que la propiedad de opacidad permite controlar la visibilidad de un elemento en la página web, la cual al declararse en un elemento la opacidad afectara tanto al elemento padre como a los elementos hijos, por lo que si se declara una opacidad de 0.5 en un elemento padre, todos los elementos hijos dentro de este elemento padre tendran una opacidad de 0.5. */
.elemento-con-opacidad{ /**Se declara un selector por clase llamado "elemento-con-opacidad".**/
    opacity: 0.8; /**Se declara una propiedad de opacidad con el valor "0.8", ocacionando que el elemento tenga una opacidad de 0.8.**/
    width: 20%; /**Se declara un ancho con el valor "20%", ocacionando que el elemento tenga un ancho de 20%.**/
    position: absolute; /**Se declara una propiedad de posicion con el valor "absolute", ocacionando que el elemento tenga una posicion absoluta.**/
    top: 0; /**Se declara una propiedad de posicion con el valor "0", ocacionando que el elemento tenga una posicion de 0px desde la parte superior.**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~NavBar */
/* ~La barra de navegación es un elemento común en las páginas web que permite a los usuarios navegar por el sitio. Por lo general, se encuentra en la parte superior de la página y contiene enlaces a las diferentes secciones del sitio. La barra de navegación puede ser horizontal o vertical, y puede incluir elementos como logotipos, menús desplegables, iconos sociales, entre otros. En este caso con todo lo visto se hara un  ejemplo de una barra de navegación */
.menu-navegacion ul{  /**Se declara un selector por etiqueta llamado "ul" dentro de la clase "menu-navegacion".**/
    list-style-type: none;  /**Se declara una propiedad de tipo de lista con el valor "none", ocacionando que no se muestre ningun tipo de lista.**/ 
    margin: 0;  /**Se declara una propiedad de margen con el valor "0", ocacionando que no se muestre ningun margen.**/
    padding: 0;  /**Se declara una propiedad de relleno con el valor "0", ocacionando que no se muestre ningun relleno.**/
    overflow: hidden;  /**Se declara una propiedad de desbordamiento con el valor "hidden", ocacionando que no se muestre ningun desbordamiento.**/
    background-color: rgb(47, 47, 47);  /**Se declara un color de fondo con el valor "rgb(47, 47, 47)", ocacionando que el fondo del elemento sea de color gris oscuro.**/
    color: white;  /**Se declara un color de texto con el valor "white", ocacionando que el texto del elemento sea de color blanco.**/
} /**Cierre de la declaracion de selector por clase.**/

.menu-navegacion li{  /**Se declara un selector por etiqueta llamado "li" dentro de la clase "menu-navegacion".**/
    float: left;  /**Se declara una propiedad de flotado con el valor "left", ocacionando que los elementos se alineen a la izquierda.**/
    margin: 0;   /**Se declara una propiedad de margen con el valor "0", ocacionando que no se muestre ningun margen.**/
    padding: 10px 20px;  /**Se declara una propiedad de relleno con el valor "10px 20px", ocacionando que se muestre un relleno de 10px en la parte superior e inferior y 20px en los lados.**/
    border-right: 1px solid white;  /**Se declara una propiedad de borde derecho con el valor "1px solid white", ocacionando que se muestre un borde derecho de 1px de color blanco.**/
    cursor: pointer; /**Se declara una propiedad de cursor con el valor "pointer", ocacionando que el cursor cambie a una mano al pasar por encima del elemento.**/
} /**Cierre de la declaracion de selector por clase.**/

.menu-navegacion li:last-child{  /**Se declara un selector por etiqueta llamado "li" dentro de la clase "menu-navegacion" y se selecciona el ultimo elemento.**/
    border-right: none;  /**Se declara una propiedad de borde derecho con el valor "none", ocacionando que no se muestre ningun borde derecho en el ultimo elemento.**/
} /**Cierre de la declaracion de selector por clase.**/

.menu-navegacion li:not(.active):hover{   /**Se declara un selector por etiqueta llamado "li" dentro de la clase "menu-navegacion" y se selecciona todos los elementos que no tengan la clase "active" al pasar el mouse por encima del elemento.**/
    background-color: purple;  /**Se declara un color de fondo con el valor "purple", ocacionando que el fondo del elemento sea de color morado al pasar el mouse por encima del elemento.**/
} /**Cierre de la declaracion de selector por clase.**/

.active{  /**Se declara un selector por clase llamado "active".**/
    background-color: rgb(6, 97, 117);  /**Se declara un color de fondo con el valor "rgb(6, 97, 117)", ocacionando que el fondo del elemento sea de color azul oscuro.**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~Selector de atributos */
/* ~Los selectores de atributos permiten seleccionar elementos HTML basados en la presencia o el valor de un atributo específico. Esto significa que los selectores de atributos permiten aplicar estilos a etiquetas, clases o id que tengan un atributo específico, como por ejemplo si un elemento "a" tiene un atributo "target", esto significa que el selector por atributo sirve para aplicar estilos a las etiquetas con  un atributo específico, donde la declaracion CSS validara si el elemento al que se hace refrecnai ya sea por clase, id o etiqueta tiene el atributo especificado dentro del selector. Por lo que para definir un selector por atributo se debe declarar el nombre del elemento, clase o id seguido de un corchete abierto, dentro del cual se declara el nombre del atributo, seguido de un corchete cerrado. Por ejemplo, para seleccionar todos los elementos "a" que tengan el atributo "target", se declararia "a[target]", en caso de querer ser mas especificos y seleccionar un atributo con un valor especifico se debe declarar el nombre del atributo seguido de un signo igual y el valor del atributo entre comillas, por ejemplo "a[target='_blank']". */
/* Todo - Selector de atributo sin valor: Para poder declarar un selector de atributo sin valor se utiliza el nombre del elemento, clase o id seguido de un corchete abierto, dentro del cual se declara el nombre del atributo, seguido de un corchete cerrado. quedando la estructura como elemento[atributo]{propiedad:valor;}. Por ende para declarar un selector de atributo sin valor se ingresa el nombre del elemento, clase o id seguido de un corchete abierto, dentro del cual se declara el nombre del atributo, seguido de un corchete cerrado. Por lo que dicho selector seleccionara todos los elementos que tengan el atributo especificado dentro del selector. */
.elemento-con-selector-de-atributo-sin-valor[target]{  /**Se declara un selector por clase llamado "elemento-con-selector-de-atributo" y se selecciona todos los elementos que tengan el atributo "target".**/
    background-color: rgb(255, 213, 0);  /**Se declara un color de fondo con el valor "rgb(255, 0, 0)", ocacionando que el fondo del elemento sea de color rojo.**/
} /**Cierre de la declaracion de selector por clase.**/

/* Todo - Selector de atributo con valor: Para poder declarar un selector de atributo con valor se utiliza el nombre del elemento, clase o id seguido de un corchete abierto, dentro del cual se declara el nombre del atributo, seguido de un signo igual y el valor del atributo entre comillas, seguido de un corchete cerrado. quedando la estructura como elemento[atributo="valor"]{propiedad:valor;}. Por ende para declarar un selector de atributo con valor se ingresa el nombre del elemento, clase o id seguido de un corchete abierto, dentro del cual se declara el nombre del atributo, seguido de un signo igual y el valor del atributo entre comillas, seguido de un corchete cerrado. Por lo que dicho selector seleccionara todos los elementos que tengan el atributo especificado dentro del selector con el valor especificado dentro del selector. */
.elemento-con-selector-de-atributo-con-valor[target="_blank"]{ /**Se declara un selector por clase llamado "elemento-con-selector-de-atributo-con-valor" y se selecciona todos los elementos que tengan el atributo "target" con el valor "_blank".**/
    background-color: greenyellow; /**Se declara un color de fondo con el valor "greenyellow", ocacionando que el fondo del elemento sea de color verde amarillento.**/
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/* ~!Important */
/* ~El uso de !important no es recomendado y debe evitarse siempre que sea posible. Esto se debe a que !important anula cualquier otra regla de estilo aplicada a un elemento, saltándose la cascada natural de CSS y la especificidad. Esto puede dificultar la depuración y el mantenimiento del código, ya que al forzar un estilo, otros estilos definidos de forma correcta pueden dejar de aplicarse. Sin embargo, !important puede usarse como último recurso cuando un estilo específico no se aplica correctamente debido a la interferencia de otras reglas. Por ejemplo si todos los enlaces <a> tienen un fondo rojo por una regla global, pero se quiere que un enlace en particular tenga fondo azul sin que la regla global lo afecte, se puede usar `background-color: blue !important;` para forzar ese estilo. Aun así, es importante recordar que abusar de !important puede hacer que el código se vuelva difícil de mantener, entender o escalar. Por eso, se recomienda usarlo solo cuando sea estrictamente necesario.  */
.contenedor-de-elementos-sin-important>div{ /**Se declara un selector por clase llamado "contenedor-de-elementos-sin-important" y se selecciona todos los elementos que sean div dentro de este contenedor.**/
    background-color: rgb(255, 143, 143); /**Se declara un color de fondo con el valor "red", ocacionando que el fondo del elemento sea de color rojo.**/
} /**Cierre de la declaracion de selector por clase.**/

.contenedor-de-elementos-sin-important>.elemento-con-important{ /**Se declara un selector por clase llamado "contenedor-de-elementos-sin-important" y se selecciona todos los elementos que tengan la clase "elemento-con-important".**/
    background-color: rgb(113, 113, 255) !important; /**Se declara un color de fondo con el valor "blue !important", ocacionando que el fondo del elemento sea de color azul y se aplique el estilo a pesar de que haya otras reglas que puedan interferir.**/
    margin: 0.5% 0;
} /**Cierre de la declaracion de selector por clase.**/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/*  ~Animaciones */
/*  ~Las animaciones en CSS permiten crear efectos visuales dinámicos y atractivos al cambiar las propiedades de un elemento a lo largo del tiempo. Esto significa que las animaciones permiten aplicar cambios graduales a las propiedades de un elemento, como el color, la posición, el tamaño, entre otros, creando una transición suave entre los estados inicial y final. Las animaciones se definen mediante keyframes, a los que se les asigna un nombre. Dentro de las llaves se definen los estados de la animación, los cuales pueden hacerse de dos formas: la primera, si solo se quiere que el elemento pase de un estado base a otro mediante una animación suave de un estado a otro, se usa "from" y "to". Esto significa que a lo largo de la animación solo se tendrán 2 estados: el estado base (que es el que tiene el elemento por defecto) y el estado final (que es al que llegará al terminar la animación). La segunda forma es si se quieren hacer más cambios durante la animación, para eso se usan porcentajes, desde 0% que es el inicio hasta 100% que es el final, y entre esos porcentajes se pueden ir aplicando distintos estilos en diferentes momentos. Esto significa que se quieren aplicar más de 2 estados en la animación, por ejemplo que un elemento no pase directamente de un color a otro o de una transparencia a otra, sino que al inicio tenga un valor, a la mitad cambie a otro distinto, y al final vuelva al original, generando así una animación con múltiples etapas definidas dentro del recorrido total del efecto. Cabe resaltar que la animacion una vez finalizada se terminara y volvera a su estado base o en caso puede ser un loop, haciendo una animacion constante infinita, por lo cual no es ideal para aplicarlo por ejemplo para hacer el efecto por ejemplo de un elemento rojo y que cuando se haga hover en este pase gradualmente a azul, ya que una vez finalizado el tiempo de animacion este volvera a ser rojo. */
/* Todo - Estructura General Keyframes: La estructura base de un keyframe en CSS se declara utilizando "@keyframes" seguido del nombre que le queramos dar a la animación. Luego se abren llaves { }, y dentro de estas se definen los estados de la animación. Estos estados pueden escribirse de dos formas: usando "from" y "to" si solo se quiere un estado inicial y uno final, o usando porcentajes (por ejemplo: 0%, 50%, 100%) si se quieren más pasos intermedios durante la animación. Cada uno de estos estados se define abriendo llaves y escribiendo dentro las propiedades CSS que se desean aplicar en ese momento de la animación. Más adelante explicaremos con detalle cada forma por separado (from-to y porcentajes), por ahora solo se muestra la estructura general del keyframe. Cabe mencionar que un keyframe por defecto unicamente se reproducira una vez. */
@keyframes nombre-keyframe{ /**Se declara un keyframe con el nombre "nombre-keyframe".**/
    /** Dentro de estas llaves se puede usar: **/
    /** "from" y "to" → para definir un estado inicial y uno final. **/
    /** porcentajes → para controlar cada momento del proceso de la animación. **/
} /** Cierre del keyframe. **/

/* ^Estructura por "From - To" del Keyframe: La estructura de un keyframe con "from" y "to" es la siguiente: @keyframes nombre-del-keyframe { from { propiedad: valor; } to { propiedad: valor; } }. Primero se declara el keyframe usando la palabra clave "@keyframes" seguida del nombre que se le asigna al keyframe, el cual posteriormente será llamado en la propiedad animation-name para aplicar la animación. Luego se abren llaves donde se definen los estados de la animación. Dentro de estas llaves, en caso de querer únicamente declarar 2 estados para la animación —uno inicial y otro final— se usa "from" con sus propias llaves, donde se colocan las propiedades y valores que corresponden al estado inicial de la animación. Después se declara "to" con sus propias llaves, donde se colocan las propiedades y valores que corresponden al estado final de la animación. Por lo que para declarar un keyframe con esta estructura, se debe declarar el nombre del keyframe, seguido de "from" abriendo llaves donde se definen las propiedades del estado inicial, y luego "to" abriendo llaves donde se definen las propiedades del estado final. */
@keyframes imagen-animation-por-from-to{ /**Se declara un keyframe con el nombre "imagen-animation-por-from-to".**/
    from{  /**Se declara el estado inicial de la animacion.**/
        opacity: 1;  /**Se declara una propiedad de opacidad con el valor "1", ocacionando que el elemento sea completamente visible al iniciar la animación.**/
    } /** Cierre de la declaracion de estado inicial.**/
    to{   /**Se declara el estado final de la animacion.**/
        opacity: 0;  /**Se declara una propiedad de opacidad con el valor "0.3", ocacionando que el elemento sea parcialmente visible al finalizar la animación.**/
    } /** Cierre de la declaracion de estado final.**/
} /** Cierre del keyframe. **/

/* ^Estructura por porcentajes del Keyframe: La estructura de un keyframe usando porcentajes es la siguiente: @keyframes nombre-del-keyframe { 0% { propiedad: valor; } 50% { propiedad: valor; } 100% { propiedad: valor; } }. Primero se declara el keyframe usando la palabra clave "@keyframes" seguida del nombre que se le asigna al keyframe, el cual posteriormente será llamado en la propiedad animation-name para aplicar la animación. Luego se abren llaves donde se definen los diferentes estados de la animación a lo largo del tiempo mediante porcentajes que van desde 0% (estado inicial) hasta 100% (estado final). Dentro de estas llaves, se declaran los porcentajes que indican en qué momento de la animación se aplican las propiedades y valores especificados. Se puede definir cualquier porcentaje desde 0% hasta 100%, las veces que se necesite (por ejemplo, 1%, 25%, 33%, 76%, etc.), no solo 0%, 50% y 100%, permitiendo así crear animaciones más detalladas y personalizadas con múltiples cambios intermedios. Esto permite definir múltiples estados intermedios entre el inicio y el final, para crear animaciones más complejas y detalladas. Por lo que para declarar un keyframe con esta estructura, se debe declarar el nombre del keyframe, seguido de uno o más porcentajes abriendo llaves donde se definen las propiedades correspondientes a cada momento específico de la animación. */
@keyframes imagen-animation-por-porcentajes{ /** Se declara un keyframe con el nombre "imagen-animation-por-porcentajes". **/
    0%{ /** Se declara el estado inicial de la animación, en el 0% del tiempo. **/
        opacity: 1; /** Se declara la propiedad de opacidad con valor "1", haciendo el elemento completamente visible al inicio. **/
    } /** Cierre de la declaración del estado en 0%. **/
    50%{ /** Se declara un estado intermedio de la animación, en el 50% del tiempo transcurrido. **/
        opacity: 0.3; /** Se declara la propiedad de opacidad con valor "0.3", haciendo el elemento parcialmente visible a mitad de la animación. **/
    } /** Cierre de la declaración del estado en 50%. **/
    100%{ /** Se declara el estado final de la animación, en el 100% del tiempo. **/
        opacity: 1; /** Se declara la propiedad de opacidad con valor "1", devolviendo el elemento a completamente visible al final. **/
    } /** Cierre de la declaración del estado en 100%. **/
} /** Cierre del keyframe. **/

/* Todo - Estructura de propiedad para aplicar animación: La estructura de la propiedad para aplicar una animación es la siguiente: selector { animation-name: nombre-del-keyframe; animation-duration: tiempo; }. Donde se declara el selector al que se le aplicara la animacion ya sea una etiqueta, clase o id, seguido de la propiedad "animation-name" ingresando como valor de dicha propiedad el nombre del keyframe que se desea aplicar, y luego se declara la propiedad "animation-duration" con el tiempo que durara la animación. Por lo que para declarar una animación se debe declarar el selector al que se le aplicara la animacion, seguido de la propiedad "animation-name" con el nombre del keyframe que se desea aplicar, y luego se declara la propiedad "animation-duration" con el tiempo que durara la animación usando el numero de segundos con "s", ya que si no se declara el nombre del keyframe y el tiempo de duración, la animación no se aplicara. Por lo que en este caso al especificarse unicamente el nombre del keyframe y el tiempo de duración, la animación se aplicara al elemento seleccionado, y al pasar el mouse por encima del elemento, este cambiara su opacidad de 1 a 0.3 en un tiempo de 1 segundo mediante una animación suave, al finalizar la animacion el elemento volvera a su estado original. */
.elemento-con-animaciones-from-to:hover{  /**Se declara un selector por clase llamado "elemento-con-animaciones-from-to" y se aplica una pseudoclase llamada "hover", la cual se activara cuando el elemento sea seleccionado.**/
    animation-name: imagen-animation-por-from-to; /**Se declara una propiedad de animacion con el nombre del keyframe "imagen-animation-por-from-to", el cual se aplicara al elemento cuando este sea seleccionado.**/
    animation-duration: 1s; /**Se declara una propiedad de duracion de la animacion con el valor "1s", ocacionando que la animacion dure 1 segundo.**/
} /** Cierre de la declaracion de selector por clase.**/

.elemento-con-animaciones-porcentajes:hover{ /**Se declara un selector por clase llamado "elemento-con-animaciones-porcentajes" y se aplica una pseudoclase llamada "hover", la cual se activara cuando el elemento sea seleccionado.**/
    animation-name: imagen-animation-por-porcentajes; /**Se declara una propiedad de animacion con el nombre del keyframe "imagen-animation-por-porcentajes", el cual se aplicara al elemento cuando este sea seleccionado.**/
    animation-duration: 3.5s;  /**Se declara una propiedad de duracion de la animacion con el valor "3.5s", ocacionando que la animacion dure 3.5 segundos.**/
} /** Cierre de la declaracion de selector por clase.**/


/* Todo - Iteracion de la animacion (animation-iteration-count): La propiedad "animation-iteration-count" se utiliza para definir cuantas veces se repetira la animacion, donde el valor puede ser un numero entero o "infinite" para que la animacion se repita indefinidamente. Por lo que si se desea que la animacion se repita un numero especifico de veces, se debe declarar la propiedad "animation-iteration-count" con el valor del numero de veces que se desea que se repita la animacion. Cabe mencionar que si se declara en una etiqueta directamente se ejecutara la animacion cuando cargue la pagina o se recargue la misma, haciendo que si se delcara una animacion con un numero de iteraciones por ejemplo en 2, estas seran las veces que se ejecutara la animacion del keyframe al cargar la pagina, y si se declara en una pseudoclase como hover, la animacion se dicha cantidad de veces al mantener el mouse sobre el elemento, y al quitar el mouse esta se detendra. */
.elemento-con-animaciones-con-contador-iteracion{ /**Se declara un selector por clase llamado "elemento-con-animaciones-con-contador-iteracion".**/
    animation-name: imagen-animation-por-porcentajes; /**Se declara una propiedad de animacion con el nombre del keyframe "imagen-animation-por-porcentajes", el cual se aplicara al elemento cuando este sea seleccionado.**/
    animation-duration: 3.5s; /**Se declara una propiedad de duracion de la animacion con el valor "3.5s", ocacionando que la animacion dure 3.5 segundos.**/
    animation-iteration-count: infinite; /**Se declara una propiedad de contador de iteracion con el valor "infinite", ocacionando que la animacion se repita indefinidamente.**/
} /** Cierre de la declaracion de selector por clase.**/

/* Todo - Restraso de la animación (animation-delay): La propiedad "animation-delay" se utiliza para definir un retraso antes de que comience la animación, donde el valor puede ser un tiempo en segundos "s", o milisegundos "ms". Esto significa que al declarar esta propiedad, se puede especificar un tiempo de espera antes de que la animación comience a ejecutarse. Por lo que si se desea que la animacion comience a ejecutarse despues de un tiempo especifico, se debe declarar la propiedad "animation-delay" con el valor del tiempo de espera que se desea antes de que la animacion comience a ejecutarse. Cabe mencionar que si se declara en un etiqueta directamente se ejecutara la animacion cuando cargue la pagina o se recargue la misma, haciendo que si se declara un animacion con un retrado de 2 segunfos, esta se ejecutara 2 segundos despues de que la pagina cargue. */
@keyframes animacion-con-delay{ /** Se declara un keyframe con el nombre "animacion-con-delay". **/
    0%{ /** Se declara el estado inicial de la animación, correspondiente al 0% del tiempo transcurrido. **/
        left: 0; /** Se establece la propiedad "left" con valor "0", lo que posiciona el elemento en su ubicación original horizontalmente. **/
    } /** Cierre de la declaración del estado en 0%. **/
    50%{ /** Se declara un estado intermedio de la animación, correspondiente al 50% del tiempo transcurrido. **/
        left: -80%; /** Se establece la propiedad "left" con valor "-80%", desplazando el elemento hacia la izquierda. **/
    } /** Cierre de la declaración del estado en 50%. **/
    100%{ /** Se declara el estado final de la animación, correspondiente al 100% del tiempo transcurrido. **/
        left: 0; /** Se establece nuevamente la propiedad "left" con valor "0", haciendo que el elemento regrese a su posición original. **/
    } /** Cierre de la declaración del estado en 100%. **/
} /** Cierre del keyframe "animacion-con-delay". **/

.elemento-con-animaciones-con-delay:active{ /** Se declara un selector por clase llamado "elemento-con-animaciones-con-delay", acompañado de la pseudoclase ":active", que se activa cuando el usuario hace clic y mantiene presionado el clic sobre el elemento. **/
    animation-name: animacion-con-delay; /** Se aplica la animación declarada anteriormente, especificando el nombre del keyframe "animacion-con-delay". **/
    animation-duration: 6s; /** Se establece la duración total de la animación en 6 segundos. **/
    animation-delay: 1s; /** Se establece un retardo de 1 segundo antes de que la animación comience a ejecutarse después de hacer clic. Esto significa que la propiedad "animation-delay" sirve para definir el tiempo de espera antes de que la animación inicie por primera vez. Si la animación está configurada para repetirse (por ejemplo, con "infinite"), este retardo solo se aplica la primera vez, y las repeticiones posteriores ocurren sin ese retraso. **/
} /** Cierre de la declaración del selector. **/

/* Todo - Dirección de animación (animation-direction): La propiedad "animation-direction" se utiliza para controlar la dirección en la que se ejecuta una animación, permitiendo que esta se reproduzca de manera normal, invertida o alternada. Esto significa que se puede definir si la animación se ejecuta del inicio al final ("normal"), del final al inicio ("reverse"), o si alterna entre ambas direcciones en cada ciclo cuando la animación se repite ("alternate" y "alternate-reverse"). Por lo que si se desea que la animación regrese en sentido contrario después de finalizar, se debe usar un valor como "alternate". Cabe mencionar que esta propiedad funciona junto con la cantidad de iteraciones definidas en "animation-iteration-count", ya que afecta cómo se comporta la animación en cada repetición, haciendo que se pueda lograr un efecto de ida y vuelta suave y continuo. */
@keyframes animacion-con-direction1{ /** Se declara un keyframe con el nombre "animacion-con-direction1". **/
    from{ /** Se declara el estado inicial de la animación mediante la palabra clave "from". **/
        left: 0; /** Se indica que la posición izquierda del elemento comienza en 0 (posición original). **/
    } /** Cierre de la declaración del estado "from". **/
    to{ /** Se declara el estado final de la animación mediante la palabra clave "to". **/
        left: 80%; /** Se indica que la posición izquierda del elemento termina en 80%, desplazándolo hacia la derecha. **/
    } /** Cierre de la declaración del estado "to". **/
} /** Cierre del keyframe "animacion-con-direction1". **/

@keyframes animacion-con-direction2{ /** Se declara un keyframe con el nombre "animacion-con-direction2". **/
    from{ /** Se declara el estado inicial de la animación mediante la palabra clave "from". **/
        left: 0; /** Se indica que la posición izquierda del elemento comienza en 0 (posición original). **/
    } /** Cierre de la declaración del estado "from". **/
    to{ /** Se declara el estado final de la animación mediante la palabra clave "to". **/
        left: -80%; /** Se indica que la posición izquierda del elemento termina en -80%, desplazándolo hacia la izquierda. **/
    } /** Cierre de la declaración del estado "to". **/
} /** Cierre del keyframe "animacion-con-direction2". **/

.animations-direction div:active{ /** Se define un selector que apunta a todos los divs dentro de la clase "animations-direction" cuando se encuentren activos (presionados con clic). **/
    animation-duration: 3s; /** Se declara que la duración de la animación será de 3 segundos. **/
} /** Cierre de la regla CSS para los divs activos dentro de "animations-direction". **/

/* &Normal */
/* &El valor de "normal" dentro de "animation-direction" es el valor que toda animación tiene por defecto, la cual se ejecuta en una sola dirección, es decir, desde el estado inicial (0%) hasta el estado final (100%) del keyframe. Esto significa que cada vez que se repite la animación, esta volverá a comenzar desde el inicio y terminará en el final, sin cambiar la dirección del movimiento o transformación. Este valor es útil cuando se desea que la animación mantenga un flujo constante y predecible, sin efectos de reversa ni ida y vuelta, por lo que es el más común en animaciones simples o unidireccionales. */
.elemento-con-animation-direction-normal:active{ /**Se declara un selector por clase llamado "elemento-con-animation-direction-normal", el cual aplica estilos cuando el elemento es activado mediante clic (pseudoclase :active).**/
    animation-name: animacion-con-direction1; /**Se declara una propiedad de animación con el valor "animacion-con-direction1", el cual indica el nombre del keyframe que se aplicará al elemento.**/
    animation-direction: normal; /**Se declara la dirección de la animación como "normal", lo que significa que la animación se reproducirá del inicio al final en cada repetición.**/
} /**Cierre de la declaración del selector por clase.**/

/* &Reverse */
/* &El valor "reverse" dentro de "animation-direction" hace que la animación se reproduzca en dirección inversa, es decir, desde el estado final (100%) hasta el estado inicial (0%) del keyframe. Esto significa que al declarar este valor, la animación no comienza como normalmente lo haría, sino que empieza desde el punto final y retrocede hasta el inicio. Este valor es útil cuando se quiere dar un efecto visual diferente sin necesidad de crear un nuevo keyframe invertido. */
.elemento-con-animation-direction-reverse:active{ /**Se declara un selector por clase llamado "elemento-con-animation-direction-reverse", el cual aplica estilos cuando el elemento es activado mediante clic (pseudoclase :active).**/
    animation-name: animacion-con-direction2; /**Se declara una propiedad de animación con el valor "animacion-con-direction2", el cual indica el nombre del keyframe que se aplicará al elemento.**/
    animation-direction: reverse; /**Se declara la dirección de la animación como "reverse", lo que hará que se ejecute desde el final hacia el inicio.**/
} /**Cierre de la declaración del selector por clase.**/

/* &Alternate */
/* &El valor "alternate" dentro de "animation-direction" hace que la animación se reproduzca de forma alternada, es decir, primero del inicio al final (ida), y luego del final al inicio (vuelta). Sin embargo, este comportamiento solo es visible si la animación se ejecuta más de una vez, ya sea mediante un número mayor a 1 en "animation-iteration-count" o con el valor "infinite". Esto significa que, si se desea que el efecto de ida y vuelta se mantenga continuamente, es necesario usar también "animation-iteration-count: infinite". */
.elemento-con-animation-direction-alternate:active{ /**Se declara un selector por clase llamado "elemento-con-animation-direction-alternate", el cual aplica estilos cuando el elemento es activado mediante clic (pseudoclase :active).**/
    animation-name: animacion-con-direction1; /**Se declara una propiedad de animación con el valor "animacion-con-direction1", el cual indica el nombre del keyframe que se aplicará al elemento.**/
    animation-direction: alternate; /**Se declara la dirección de la animación como "alternate", haciendo que esta se reproduzca primero hacia adelante y luego hacia atrás.**/
    animation-iteration-count: infinite; /**Se declara una propiedad de repetición de animación con el valor "infinite", lo que permite que el efecto de ida y vuelta ocurra de manera continua.**/
} /**Cierre de la declaración del selector por clase.**/

/* &Alternate reverse */
/* &El valor "alternate-reverse" dentro de "animation-direction" funciona de forma similar a "alternate", pero invierte el orden inicial. En este caso, la animación se ejecuta primero desde el final hacia el inicio (vuelta), y luego desde el inicio hacia el final (ida). Al igual que con "alternate", este comportamiento solo será visible si la animación se repite más de una vez, por ejemplo, usando "animation-iteration-count: infinite". Esto permite que la animación se repita de forma alternada y en reversa continuamente. */
.elemento-con-animation-direction-alternate-reverse:active{ /**Se declara un selector por clase llamado "elemento-con-animation-direction-alternate-reverse", el cual aplica estilos cuando el elemento es activado mediante clic (pseudoclase :active).**/
    animation-name: animacion-con-direction2; /**Se declara una propiedad de animación con el valor "animacion-con-direction2", el cual indica el nombre del keyframe que se aplicará al elemento.**/
    animation-iteration-count: infinite; /**Se declara una propiedad de repetición de animación con el valor "infinite", lo que permite que el efecto se repita continuamente.**/
    animation-direction: alternate-reverse; /**Se declara la dirección de la animación como "alternate-reverse", haciendo que esta se ejecute primero en reversa (del final al inicio) y luego en su orden normal.**/
} /**Cierre de la declaración del selector por clase.**/

/* Todo - Función del tiempo de la animación (animation-timing-function): La propiedad "animation-timing-function" se utiliza para definir la velocidad con la que progresa una animación a lo largo del tiempo. No afecta la duración total de la animación, sino cómo se distribuye el movimiento en ese periodo. Por ejemplo, puede hacer que el movimiento sea constante ("linear"), que comience lento y luego acelere ("ease-in"), o que inicie rápido y termine lentamente ("ease-out"). También existen combinaciones como "ease-in-out", que inicia y finaliza lento pero acelera en la mitad. Estos valores afectan visualmente la fluidez y el ritmo de las transiciones animadas, permitiendo hacerlas más realistas o estéticas. Aunque esta propiedad no se declara dentro de los keyframes, su efecto se manifiesta en cómo se interpretan los cambios entre los estados definidos en ellos. El siguiente keyframe es utilizado para probar cómo se comportan estos distintos valores al aplicarse. */
@keyframes animacion-funcion-tiempo { /** Se declara un conjunto de keyframes con el nombre "animacion-funcion-tiempo". **/
    0% { /** Se define el primer estado de la animación al 0% del tiempo total (inicio). **/
        background-color: #ff2929; /** El color de fondo comienza en rojo brillante. **/
        left: 1%; /** El elemento inicia desplazado hacia la izquierda (1% desde el borde izquierdo del contenedor). **/
    } /** Cierre del bloque del 0%. **/
    25% { /** Se define el estado al 25% del tiempo total de la animación. **/
        background-color: rgb(89, 255, 0); /** El fondo cambia a un tono verde fosforescente. Ademas que no se especifica "left", por lo tanto mantiene la posición del paso anterior. */
    } /** Cierre del bloque del 25%. **/
    50% { /** Se define el estado al 50% del tiempo total. **/
        background-color: rgb(0, 191, 255); /** El fondo cambia a un azul brillante. **/
    } /** Cierre del bloque del 50%. **/
    75% { /** Se define el estado al 75% del tiempo total. **/
        background-color: rgb(183, 0, 255); /** El fondo pasa a un color púrpura intenso. **/
    } /** Cierre del bloque del 75%. **/
    100% { /** Se define el estado final de la animación al 100% del tiempo total. **/
        background-color: rgb(255, 221, 0); /** El fondo termina en un amarillo vibrante. **/
        left: 94%; /** El elemento se mueve hacia la derecha, posicionándose en un 94% desde el borde izquierdo del contenedor. **/
    } /** Cierre del bloque del 100%. **/
} /** Cierre completo del keyframe "animacion-funcion-tiempo". **/

.animaciones-con-funcion-del-tiempo>div>div{ /**Se declara un selector que selecciona todos los <div> que están dentro de otro <div>, el cual a su vez está dentro de un elemento con la clase "animaciones-con-funcion-del-tiempo".**/
    animation-name: animacion-funcion-tiempo; /**Se declara la propiedad "animation-name" con el valor "animacion-funcion-tiempo", lo que indica que se aplicará al elemento el keyframe con ese nombre.**/
    animation-duration: 3.5s; /**Se establece una duración de 3.5 segundos para completar un ciclo completo de la animación.**/
    animation-iteration-count: infinite; /**Se indica que la animación debe repetirse infinitamente, sin detenerse.**/
    animation-direction: alternate; /**Se especifica que la animación debe alternar su dirección, es decir, se reproduce primero hacia adelante y luego hacia atrás en cada ciclo.**/
} /**Cierre de la declaración del selector descendente.**/

/* &Linear */
/* &El valor "linear" dentro de la propiedad "animation-timing-function" produce una animación con velocidad constante desde el inicio hasta el final. No hay aceleraciones ni desaceleraciones, lo que da como resultado un movimiento uniforme durante toda la duración de la animación. Ademas este es el valor por defecto de toda keyframe. */
.elemento-con-funcion-tiempo-linear{ /**Se declara un selector por clase llamado "elemento-con-funcion-tiempo-linear".**/
    animation-timing-function: linear; /**Se aplica la función de tiempo "linear", haciendo que la animación avance a una velocidad constante en todo momento.**/
} /**Cierre de la declaración del selector por clase.**/

/* &Ease */
/* &El valor "ease" es el valor por defecto de "animation-timing-function". Este tipo de animación inicia lentamente, luego acelera en el medio y termina disminuyendo la velocidad. Es útil para dar un efecto natural y suave a las animaciones. */
.elemento-con-funcion-tiempo-ease{ /**Se declara un selector por clase llamado "elemento-con-funcion-tiempo-ease".**/
    animation-timing-function: ease; /**Se aplica la función de tiempo "ease", la cual genera un efecto suave comenzando lento, acelerando y luego desacelerando hacia el final.**/
} /**Cierre de la declaración del selector por clase.**/

/* &Ease-in */
/* &El valor "ease-in" hace que la animación comience lentamente y luego aumente su velocidad progresivamente. Es ideal cuando se desea un arranque sutil que se vuelve más rápido con el tiempo. */
.elemento-con-funcion-tiempo-ease-in{ /**Se declara un selector por clase llamado "elemento-con-funcion-tiempo-ease-in".**/
    animation-timing-function: ease-in; /**Se aplica la función de tiempo "ease-in", haciendo que la animación comience despacio y luego acelere.**/
} /**Cierre de la declaración del selector por clase.**/

/* &Ease-in-out */
/* &El valor "ease-in-out" combina los efectos de "ease-in" y "ease-out". La animación comienza lentamente, acelera en el medio y luego desacelera al final. Este valor es ideal para animaciones balanceadas y naturales. */
.elemento-con-funcion-tiempo-ease-in-out{ /**Se declara un selector por clase llamado "elemento-con-funcion-tiempo-ease-in-out".**/
    animation-timing-function: ease-in-out; /**Se aplica la función de tiempo "ease-in-out", haciendo que la animación empiece y termine despacio, acelerando solo en el centro.**/
} /**Cierre de la declaración del selector por clase.**/

/* &Ease-out */
/* &El valor "ease-out" hace que la animación comience rápidamente y luego se desacelere hacia el final. Es útil cuando se desea que la animación termine de manera suave. */
.elemento-con-funcion-tiempo-ease-out{ /**Se declara un selector por clase llamado "elemento-con-funcion-tiempo-ease-out".**/
    animation-timing-function: ease-out; /**Se aplica la función de tiempo "ease-out", haciendo que la animación empiece rápido y termine lentamente.**/
} /**Cierre de la declaración del selector por clase.**/

/* Todo - Shorthand de animaciones (animation{}): Es una propiedad abreviada que permite declarar múltiples propiedades de animación en una sola línea. Con esta shorthand se pueden definir el nombre del keyframe, la duración, la función de tiempo, el retraso, la cantidad de repeticiones, la dirección, el modo de llenado (fill mode) y si la animación es o no pausada. El orden sugerido para declarar estas propiedades dentro del shorthand es: animation-name, animation-duration, animation-timing-function, animation-delay, animation-iteration-count, animation-direction, animation-fill-mode, animation-play-state. Usar esta propiedad facilita la escritura y lectura del código, ya que se pueden evitar múltiples líneas declarando propiedades por separado. Además, no es obligatorio declarar todas las propiedades; se pueden omitir las que no se necesiten. Un ejemplo completo del uso del shorthand podría ser: animation: mover 3s ease-in 1s infinite alternate both running; lo que indica que la animación llamada "mover" durará 3 segundos, iniciará con un retraso de 1 segundo, se repetirá infinitamente, cambiará de dirección en cada ciclo, mantendrá el estilo aplicado cuando termine, y estará en estado de reproducción. No es necesario que se declaren todas las propiedades, ya que aquellas que no se especifiquen toamran valores por defecto. */
@keyframes animacion-shorthand { /** Se declara un conjunto de keyframes con el nombre "animacion-shorthand". **/
    0% { /** Se define el estado inicial de la animación, al 0% del tiempo total. **/
        background-color: rgb(0, 191, 255); /** El color de fondo comienza en un tono azul brillante. **/
        left: 0; /** La posición izquierda del elemento inicia en 0, es decir, pegado al borde izquierdo del contenedor. **/
        top: 0; /** La posición superior del elemento también comienza en 0, es decir, en la parte superior del contenedor. **/
    } /** Cierre del bloque del 0%. **/
    25% { /** Se define el estado al 25% del tiempo total. **/
        background-color: rgb(183, 0, 255); /** El fondo cambia a un púrpura intenso. **/
        left: 98%; /** El elemento se mueve casi completamente hacia la derecha del contenedor (98% desde el borde izquierdo). **/
        top: 0; /** La posición superior permanece en la parte superior. **/
    } /** Cierre del bloque del 25%. **/
    50% { /** Se define el estado al 50% del tiempo total. **/
        background-color: #ff2929; /** El color de fondo cambia a rojo brillante. **/
        left: 98%; /** El elemento se mantiene en el borde derecho. **/
        top: 37%; /** El elemento se desplaza hacia abajo en un 37% desde la parte superior del contenedor. **/
    } /** Cierre del bloque del 50%. **/
    75% { /** Se define el estado al 75% del tiempo total. **/
        background-color: rgb(89, 255, 0); /** El fondo cambia a un verde fosforescente. **/
        left: 0; /** El elemento regresa al borde izquierdo. **/
        top: 37%; /** La posición superior se mantiene en 37%. **/
    } /** Cierre del bloque del 75%. **/
    100% { /** Se define el estado final de la animación, al 100% del tiempo total. **/
        background-color: rgb(0, 191, 255); /** El fondo vuelve al azul brillante, como al inicio. **/
        left: 0; /** La posición izquierda vuelve a 0. **/
        top: 0; /** La posición superior también vuelve a 0. **/
    } /** Cierre del bloque del 100%. **/
} /** Cierre completo del keyframe "animacion-shorthand". **/

.elemento-con-animacion-shorthand { /** Se declara un selector por clase llamado "elemento-con-animacion-shorthand". **/
    animation: animacion-shorthand 6s linear 3s infinite alternate; /** Se utiliza la propiedad shorthand "animation" para definir múltiples valores en una sola línea, se declara el nombre del keyframe a utilizar, se indica que la animación completa dura 6 segundos, que la función de tiempo es lineal, que la animación inicia después de 3 segundos, que se repite infinitamente y que alterna la dirección en cada ciclo. **/
}

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/*  ~Transiciones */
/*  ~Las transiciones en CSS permiten aplicar cambios graduales a una o varias propiedades de un elemento cuando este cambia de estado, como por ejemplo al hacer hover, focus o activar un botón. Esto quiere decir que en lugar de que el cambio ocurra de forma instantánea, se puede hacer que suceda de manera progresiva y suave, generando una experiencia visual más agradable. Para lograrlo se utiliza la propiedad "transition", en la cual se puede especificar qué propiedad se quiere que cambie, cuánto tiempo debe durar el cambio, la función de aceleración (como ease o linear), y un posible retraso antes de comenzar. A diferencia de las animaciones, las transiciones no utilizan keyframes ni múltiples etapas, ya que solo definen un cambio entre dos estados: el estado inicial (por defecto) y el estado final (activado por una interacción como hover o focus). Es decir, si un botón tiene un color de fondo rojo y se le aplica una transición junto con un estilo hover con fondo azul, al pasar el cursor por encima el cambio de rojo a azul será suave y no instantáneo. Sin embargo, una vez que el cursor se retira, el elemento volverá a su estado inicial también con un cambio gradual. Es importante notar que las transiciones solo se activan cuando ocurre un cambio en el estado del elemento y duran únicamente el tiempo indicado; no se repiten por sí solas como las animaciones, y no permiten definir múltiples pasos intermedios. Por ello, son ideales para efectos simples y rápidos como desvanecimientos, cambios de color, tamaño o posición durante una interacción, pero no para secuencias complejas o automatizadas. Cabe resaltar que para poder aplicar transiciones se necesitan dos estados: una que define el estado base del elemento y otra que define el estado modificado (por ejemplo, usando la pseudoclase :hover). Por lo tanto, es importante tener en cuenta que si las propiedades de transición se declaran **en el estado base** del elemento, como por ejemplo `.miElemento`, el cambio hacia el estado `:hover` y el regreso al estado original serán ambos suaves. Pero si se declaran solo dentro del estado `:hover`, la transición se aplicará **solo al entrar** en el hover, y **el regreso al estado base será inmediato** (sin efecto visual), ya que el elemento ya no está bajo las reglas de `:hover` */
/* Todo - Estructura de propiedad para aplicar una transición: La estructura para aplicar una transición correctamente es la siguiente: selector { transition-property: propiedad; transition-duration: tiempo; }. Primero se declara el selector al que se le aplicará la transición, ya sea una etiqueta, clase o id. Luego se declara la propiedad "transition-property", donde se especifica qué propiedad o propiedades deben ser afectadas por la transición (por ejemplo, "background-color", "opacity", "transform", etc.). Es importante declarar esta propiedad, ya que si no se indica, los cambios en otras propiedades no serán animados y simplemente aparecerán de forma repentina. Después se declara "transition-duration", donde se establece cuánto tiempo debe durar la transición. Este valor se define generalmente en segundos usando "s" (por ejemplo: 1s). Si no se especifica un tiempo de duración, aunque se haya indicado la propiedad a animar, el cambio también ocurrirá de forma instantánea, sin ningún efecto visual gradual. Por lo tanto, para que una transición funcione correctamente y se vea el cambio suave entre dos estados, como por ejemplo al pasar el cursor sobre un elemento, se deben declarar **tanto** "transition-property" como "transition-duration" en el estado base del elemento. Esto asegura que al cambiar de estado (como al aplicar ":hover"), la transición se aplique solo a las propiedades deseadas, con la duración especificada, y se genere un efecto visual atractivo y controlado. */
.elemento-con-transicion { /**Se declara un selector por clase llamado "elemento-con-transicion", el cual aplica estilos al estado base del elemento.**/
    background-color: rgb(128, 255, 0); /**Se aplica un color de fondo verde fosforescente mediante la propiedad "background-color".**/
    transition-property: background; /**Se especifica que solo la propiedad "background" será la que tendrá una transición.**/
    transition-duration: 3s; /**Se define que la duración de la transición será de 3 segundos.**/
} /**Cierre de la declaración del selector por clase.**/

.elemento-con-transicion:hover { /**Se declara una regla para la pseudoclase ":hover", que se activa cuando el cursor pasa sobre el elemento.**/
    background-color: rgb(0, 221, 255); /**Se cambia el color de fondo a un azul celeste, lo cual se hará de forma suave gracias a la transición.**/
} /**Cierre de la declaración de la pseudoclase ":hover".**/

/* Todo - Función del tiempo de la transición (transition-timing-function):  Al igual que en las animaciones, existe la propiedad "transition-timing-function" en las transiciones, la cual define la velocidad con la que progresa el cambio de una propiedad a lo largo del tiempo. Esta propiedad no afecta la duración total de la transición, sino la forma en que el cambio se distribuye dentro de ese tiempo. Por ejemplo, el valor "linear" hace que el cambio ocurra a velocidad constante durante toda la transición. El valor "ease-in" hace que el cambio comience lento y luego acelere hacia el final. Por otro lado, "ease-out" hace que el cambio inicie rápido y termine lentamente, mientras que "ease-in-out" combina ambas, iniciando y terminando lento pero acelerando en la mitad del proceso. Estos valores permiten controlar la fluidez y la sensación visual de la transición, haciendo que los cambios sean más naturales, suaves o dinámicos según se desee. Para ver las diferencias de forma mas entendible visualiza la pagina en el navegaro y ve a la seccion de "animation-timing-function" */
.elemento-con-tiempo-de-transicion { /**Se declara un selector por clase llamado "elemento-con-tiempo-de-transicion", el cual aplica estilos al estado base del elemento.**/
    outline: 3px solid rgb(255, 0, 204); /**Se aplica un contorno (outline) de 3 píxeles de grosor y color rosa neón alrededor del elemento.**/
    transition-property: outline; /**Se especifica que solo la propiedad "outline" será afectada por la transición.**/
    transition-duration: 1s; /**Se define que la transición tendrá una duración de 1 segundo.**/
    transition-timing-function: ease-in; /**Se declara la función de tiempo como "ease-in", lo que significa que la transición comenzará lentamente y acelerará hacia el final.**/
} /**Cierre de la declaración del selector por clase.**/

.elemento-con-tiempo-de-transicion:hover { /**Se declara una regla para la pseudoclase ":hover", que se activa cuando el cursor pasa sobre el elemento.**/
    outline: 5px solid orangered; /**Se cambia el contorno a 5 píxeles de grosor y color naranja, lo cual ocurrirá de forma suave gracias a la transición definida en el estado base.**/
} /**Cierre de la declaración de la pseudoclase ":hover".**/

/* Todo - Retraso en la transición (transition-delay):  Al igual que en las animaciones, en las transiciones también existe la propiedad "transition-delay", la cual permite establecer un tiempo de espera antes de que comience el cambio de una propiedad. Esta propiedad no modifica ni la duración ni la velocidad del cambio, sino que retrasa su inicio una vez que se activa la transición (por ejemplo, al pasar el cursor con :hover). Por ejemplo, si se establece un delay de "2s", la transición esperará dos segundos antes de comenzar a ejecutarse desde el momento en que se activa el evento. Esto resulta útil cuando se desea crear un efecto más pausado o cuando se quieren coordinar múltiples transiciones en diferentes elementos para que ocurran de manera escalonada. Al igual que con las animaciones, los valores de "transition-delay" se expresan en segundos (s) o milisegundos (ms). */
.elemento-con-transicion-con-delay { /**Se declara un selector por clase llamado "elemento-con-transicion-con-delay", el cual aplica estilos al estado base del elemento.**/
    background: url('../assets/images/backgrounds/Background_Image_7.jpg') no-repeat top/cover; /**Se aplica una imagen de fondo desde la ruta indicada, sin repetición (no-repeat), alineada arriba (top) y ajustada para cubrir todo el contenedor (cover).**/
    color: white; /**Se define el color del texto como blanco.**/
    transition-property: background, color; /**Se especifica que las propiedades "background" y "color" serán afectadas por la transición.**/
    transition-duration: 2s; /**Se establece que la duración de la transición será de 2 segundos.**/
    transition-delay: 1s; /**Se indica que la transición tendrá un retraso de 1 segundo antes de comenzar a ejecutarse.**/
} /**Cierre de la declaración del selector por clase.**/

.elemento-con-transicion-con-delay:hover { /**Se declara una regla para la pseudoclase ":hover", que se activa cuando el cursor pasa sobre el elemento.**/
    background: url('../assets/images/backgrounds/Background_Image_8.jpg') no-repeat top/cover; /**Se cambia la imagen de fondo por otra, manteniendo la alineación, repetición y ajuste anteriores.**/
    color: black; /**Se cambia el color del texto a negro, y este cambio también será afectado por la transición con retardo.**/
} /**Cierre de la declaración de la pseudoclase ":hover".**/

/* Todo - Shorthand de transiciones (transition): Esta propiedad abreviada permite definir varias características de una transición en una sola línea, facilitando la escritura y lectura del código. Con el shorthand se pueden especificar las propiedades que cambiarán (transition-property), la duración de la transición (transition-duration), la función de tiempo que controla la velocidad del cambio (transition-timing-function) y el retraso antes de iniciar la transición (transition-delay). El orden recomendado para declarar estas subpropiedades en el shorthand es: transition-property, transition-duration, transition-timing-function, transition-delay. No es obligatorio declarar todas, se pueden omitir las que no se requieran. Por ejemplo: transition: background-color 2s ease-in 0.5s; indica que la propiedad background-color cambiará en 2 segundos, con una aceleración inicial lenta (ease-in) y comenzará medio segundo después de activarse. Usar esta shorthand permite un código más limpio y organizado, evitando múltiples líneas separadas para cada subpropiedad de la transición. Además, si se desean aplicar transiciones a más de una propiedad al mismo tiempo, se pueden separar dentro del shorthand con una coma. Por ejemplo: transition: opacity 1s linear 1s, width 1s linear; define dos transiciones distintas para las propiedades "opacity" y "width". */
.elemento-con-transicion-shorthand > img { /** Se declara un selector que apunta a las imágenes hijas directas del elemento con clase "elemento-con-transicion-shorthand". **/
    opacity: 0.3; /** Se establece la opacidad inicial de la imagen en 0.3, haciendo que se vea parcialmente transparente. **/
    width: 110px; /** Se establece un ancho inicial de 110 píxeles para la imagen. **/
    transition: opacity 1s linear 1s, width 1s linear; /** Se define una shorthand de transición que aplica a dos propiedades: "opacity", la cual cambiará con una duración de 1 segundo, función de tiempo lineal y con un retardo de 1 segundo; y "width", que cambiará en 1 segundo con función de tiempo lineal pero sin retardo. Las transiciones múltiples se separan por comas dentro del shorthand. **/
} /** Cierre de la declaración del selector para la imagen. **/

.elemento-con-transicion-shorthand > img:hover { /** Se declara una regla para la pseudoclase ":hover" que se activa cuando el cursor pasa sobre la imagen dentro del elemento con clase "elemento-con-transicion-shorthand". **/
    opacity: 1; /** Se cambia la opacidad de la imagen a 1 (totalmente visible) cuando se pasa el cursor por encima, aplicando la transición definida anteriormente para que el cambio sea suave. **/
    width: 130px; /** Se aumenta el ancho de la imagen a 130 píxeles al pasar el cursor, utilizando la transición definida para un cambio gradual. **/
} /** Cierre de la declaración de la pseudoclase ":hover" para la imagen. **/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/*  ~MediaQueries */
/*  ~Las media queries en CSS permiten aplicar estilos específicos a un documento dependiendo del tamaño de la pantalla o del dispositivo donde se visualiza. Esto significa que podemos hacer que el diseño y comportamiento de un sitio web se adapten automáticamente a diferentes resoluciones, como teléfonos, tablets o pantallas de escritorio. Con esta técnica se implementa el diseño responsivo, lo cual mejora la experiencia del usuario al asegurar que los elementos se vean y funcionen correctamente sin importar el dispositivo utilizado. Para lograrlo, se utiliza la regla `@media`, dentro de la cual se definen condiciones que evalúan características del dispositivo, como el ancho (`width`), la altura (`height`), la orientación (`orientation`), la resolución (`resolution`), entre otras. Las más comunes son las relacionadas al ancho de la pantalla, utilizando expresiones como `min-width` (ancho mínimo) o `max-width` (ancho máximo). Por ejemplo, con `@media (max-width: 768px)` se indican estilos que se aplicarán **solo si el ancho de la pantalla es igual o menor a 768 píxeles**, ideal para tablets o móviles. De forma contraria, `@media (min-width: 1024px)` aplica los estilos **solo si la pantalla tiene al menos 1024 píxeles de ancho**, útil para pantallas más grandes como laptops o escritorios. Estas condiciones permiten crear "puntos de quiebre" (breakpoints), donde el diseño puede ajustarse según el tamaño del dispositivo. Por ejemplo, un contenedor que en pantalla grande muestra tres columnas, puede reorganizarse a una sola columna en dispositivos móviles gracias a las media queries. También se pueden cambiar tamaños de fuentes, ocultar elementos, modificar márgenes, cambiar imágenes, y más, para asegurar legibilidad y usabilidad en distintos contextos. Es importante tener en cuenta que los estilos **base u ordinarios** se declaran fuera de las media queries, y se aplican cuando **el tamaño de la pantalla no cumple ninguna de las condiciones especificadas**. Es decir, las media queries solo entran en acción si se cumple la condición del tamaño, mientras que en cualquier otro caso, los estilos generales se mantendrán activos por defecto. Además, no es necesario volver a declarar absolutamente todos los estilos dentro de las media queries; **solo aquellas propiedades que se quieran modificar o sobrescribir**. Por ejemplo, si una imagen tiene originalmente un `height: 500px` y `float: left`, y dentro de una media query solo se especifica `float: none`, entonces **únicamente esa propiedad será reemplazada**, manteniéndose el `height: 500px` intacto. Esto permite escribir código más limpio, reutilizable y fácil de mantener, ya que las media queries actúan como ajustes puntuales sobre los estilos ya definidos. Es recomendable colocar las media queries **al final de la hoja de estilos**, o después de los estilos generales, para asegurar que sus reglas puedan sobrescribir correctamente a las anteriores cuando se cumpla la condición. En resumen, las media queries son una herramienta fundamental para lograr que un sitio sea adaptable, accesible y visualmente coherente en cualquier dispositivo. */
/* Todo - Estructura General Media Queries: La estructura base de una media query en CSS se declara utilizando "@media" seguido de una condición entre paréntesis que define **cuándo** se deben aplicar ciertos estilos. Esta condición puede evaluar características del dispositivo como el ancho (`width`), la altura (`height`), la orientación (`orientation`), la resolución (`resolution`), entre otras. Las más comunes son `min-width` (ancho mínimo) y `max-width` (ancho máximo), que permiten aplicar estilos específicos según el tamaño de la pantalla. La condición se escribe inmediatamente después del `@media`, entre paréntesis. Por ejemplo: `@media (max-width: 768px)` aplicará los estilos **solo si la pantalla tiene 768 píxeles de ancho o menos**. Si se desea combinar **dos condiciones**, se utiliza la palabra clave `and` entre ambas, como en: `@media (min-width: 480px) and (max-width: 768px)`. Esto significa que los estilos se aplicarán **solo si el ancho de la pantalla está entre 480px y 768px**. Es totalmente válido usar dos `max`, dos `min`, o una combinación de ambas (`min-width` y `max-width`), dependiendo del rango de pantalla que se quiera cubrir. Después de establecer la(s) condición(es), se abren llaves { } y dentro de ellas se escriben los **selectores y estilos CSS** que se aplicarán solo si se cumple la condición. Es decir, lo que esté dentro del bloque de la media query solo afectará a los elementos cuando se cumpla esa condición. Cabe resaltar que dentro de una media query **solo es necesario declarar las propiedades que se quieran modificar** respecto al estilo base. Todo lo demás se mantiene sin cambios. Esto permite adaptar un diseño sin reescribir todo el código CSS. */
@media (condición) { /** Se abre una media query con la condición especificada, por ejemplo: (max-width: 768px). **/
    selector { /** Se escribe el selector del elemento al que se le aplicarán los estilos si se cumple la condición. **/
        propiedad: valor; /** Aquí se declaran solo las propiedades que se deseen sobrescribir cuando se cumpla la condición. **/
    } /** Cierre del selector. **/
} /** Cierre del bloque de la media query. **/

/* Todo - Estructura para aplicar Media Queries: Primero se declaran los estilos base (sin media queries) para los selectores, los cuales se aplican por defecto en todos los tamaños de pantalla. Después, se escriben las media queries usando `@media` con condiciones específicas entre paréntesis (por ejemplo, `(max-width: 768px)`), que indican **cuándo** se deben aplicar ciertos estilos diferentes.  Dentro de estas media queries se incluyen solo los selectores y las propiedades CSS que se desean modificar o sobrescribir respecto a los estilos base.  Esto significa que **no es necesario repetir todas las propiedades**, solo aquellas que cambian para ese punto de quiebre o condición específica. Es recomendable colocar las media queries al final de la hoja de estilos o después de los estilos base, para asegurar que puedan sobrescribir correctamente las reglas anteriores cuando se cumpla la condición. */
.elemento-con-mediaqueries{ /** Se declara un selector por clase llamado "elemento-con-mediaqueries" al que se le aplicarán estilos generales por defecto. **/
    background-color: rgb(106, 153, 255); /** Se define el color de fondo azul claro para el contenedor. **/
    color: black; /** Se establece el color del texto en negro. **/
    text-align: justify; /** Se alinea el texto justificado para mejorar la lectura. **/
} /** Cierre del selector base. **/

.elemento-con-mediaqueries>img{ /** Se selecciona la imagen hija directa del elemento con la clase "elemento-con-mediaqueries". **/
    width: 20%; /** Se define un ancho del 20% para la imagen. **/
    margin-right: 1.6%; /** Se establece un margen derecho de 1.6% para separar la imagen del texto. **/
    float: left; /** Se indica que la imagen debe flotar a la izquierda del contenido. **/
} /** Cierre del selector para imagen. **/

@media (max-width: 450px){ /** Se abre una media query que se activará cuando el ancho de pantalla sea de 450px o menor. **/
    .elemento-con-mediaqueries{ /** Se vuelve a llamar al mismo selector para modificar algunos de sus estilos. **/
        background-color: rgb(0, 0, 0); /** Se cambia el color de fondo a negro. **/
        color: white; /** Se cambia el color del texto a blanco para mejor contraste. **/
    } /** Cierre del selector dentro del media query. **/

    .elemento-con-mediaqueries>img{ /** Se modifica el selector de la imagen solo en este punto de quiebre. **/
        width: 100%; /** Se cambia el ancho de la imagen para ocupar todo el ancho disponible. **/
        position: none; /** Se intenta cancelar una posición (aunque "none" no es un valor válido para position). **/
    } /** Cierre del selector de imagen dentro del media query. **/
} /** Cierre del bloque de la media query para max-width: 450px. **/

@media (min-width: 450px) and (max-width: 800px){ /** Se abre una media query combinada que se activará entre 450px y 800px de ancho. **/
    .elemento-con-mediaqueries{ /** Se modifican estilos del mismo selector, aplicables solo dentro de este rango. **/
        background-color: rgb(170, 73, 255); /** Se establece un color morado como fondo para este punto de quiebre. **/
        color: black; /** Se mantiene el color del texto en negro. **/
    } /** Cierre del selector dentro de la media query. **/

    .elemento-con-mediaqueries>img{ /** Se ajusta el estilo de la imagen dentro de este rango. **/
        width: 50%; /** Se asigna un ancho del 50% a la imagen. **/
        float: right; /** Se cambia el flotado hacia la derecha. **/
    } /** Cierre del selector de imagen dentro del media query. **/
} /** Cierre del bloque de la media query combinada. **/

/*/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
/*  ~Flexbox */
/*  ~Flexbox en CSS es un modelo de diseño unidimensional que permite organizar elementos hijos de forma más eficiente dentro de un contenedor, especialmente cuando se trata de alineación y distribución del espacio. Este sistema solo se activa cuando al contenedor se le aplica la propiedad `display: flex`, lo cual convierte automáticamente a todos sus hijos directos en elementos flexibles. Una vez que el contenedor es un "flex container", el comportamiento por defecto de los elementos hijos cambia: en lugar de apilarse uno debajo del otro como en el flujo normal del documento, estos se organizan en una sola fila horizontal, alineados de izquierda a derecha. Sin embargo, este comportamiento por defecto puede ser modificado mediante diferentes propiedades específicas de Flexbox que permiten personalizar tanto la dirección de los elementos como su alineación y su comportamiento en distintas condiciones. Entre estas propiedades se encuentran `flex-direction`, que define la dirección del eje principal (horizontal o vertical), `flex-wrap`, que permite que los elementos se acomoden en múltiples líneas si no caben en una sola, `justify-content`, que controla la distribución de los elementos a lo largo del eje principal, `align-items`, que alinea los elementos en el eje cruzado (perpendicular al principal), y `align-content`, que actúa sobre el espacio entre las filas cuando hay múltiples líneas. Estas propiedades trabajan en conjunto para ofrecer un control completo y flexible sobre la disposición de los elementos dentro de un contenedor. En resumen, Flexbox es una herramienta poderosa para crear diseños adaptables, ordenados y centrados con menos esfuerzo que con métodos tradicionales, pero su funcionamiento está siempre condicionado a que el contenedor tenga `display: flex`, ya que de lo contrario, estas propiedades no tendrán ningún efecto. */
/* Todo - Dirección del flex (flex-direction):   La propiedad "flex-direction" se utiliza para controlar la dirección en la que se organizan los elementos hijos dentro de un contenedor que tiene aplicado "display: flex". Esto significa que define si los elementos se distribuyen en fila o columna, y también el orden en que se presentan dentro de ese eje.   Por defecto, los elementos se organizan en una fila horizontal de izquierda a derecha ("row"), que es el comportamiento estándar en la mayoría de los casos. Sin embargo, con "flex-direction" se puede cambiar esta dirección para que los elementos se dispongan en columna vertical ("column"), o invertir el orden de los elementos ya sea en fila ("row-reverse") o en columna ("column-reverse").   Así, esta propiedad permite adaptar fácilmente la estructura visual y el flujo del contenido dentro de un contenedor flexible, sin necesidad de cambiar el HTML. Es importante recordar que "flex-direction" solo funciona cuando el contenedor tiene "display: flex", y es una de las propiedades fundamentales para controlar la disposición de los elementos dentro del modelo Flexbox. */
/* &Row */
/* &El valor "row" dentro de "flex-direction" es el valor predeterminado que se aplica cuando se usa "display: flex" en un contenedor. Este valor organiza todos los elementos hijos en una sola fila, colocándolos de izquierda a derecha según el orden en que aparecen en el HTML. Esto significa que, sin necesidad de declarar explícitamente "flex-direction: row", los elementos ya se disponen en línea horizontal de forma natural. Este comportamiento es útil para estructuras de navegación, barras de herramientas o cualquier diseño donde los elementos deban ir uno al lado del otro en un mismo renglón. Además, este valor respeta el flujo natural del documento, por lo que es ideal cuando no se requiere una reorganización compleja del contenido. En resumen, "row" ofrece una distribución clara y directa, lo que lo convierte en el valor más utilizado al trabajar con Flexbox en diseños horizontales. */
.elemento-con-flex-direction-row{
    display: flex;
    flex-direction: row;
}

/* &Row-reverse */
/* &El valor "row-reverse" en la propiedad "flex-direction" organiza los elementos hijos en una fila (horizontal), pero a diferencia de "row", estos se muestran en dirección de derecha a izquierda. Esto significa que el primer elemento escrito en el HTML se colocará visualmente al final (a la derecha), el segundo un lugar antes, y así sucesivamente, invirtiendo su orden natural. Este comportamiento solo se activa cuando el contenedor tiene la propiedad "display: flex", lo que hace que todos los elementos hijos se acomoden en una sola línea (por defecto en horizontal). Al aplicar "row-reverse", el flujo visual cambia: los elementos siguen alineados horizontalmente, pero su dirección es opuesta. Es importante mencionar que esta propiedad solo cambia la forma en que los elementos se muestran visualmente, no el orden real en que están escritos en el HTML. */
.elemento-con-flex-direction-row-reverse{
    display: flex;
    flex-direction: row-reverse;
}

/* &Column  
/* &El valor "column" en la propiedad "flex-direction" organiza los elementos hijos en una columna (vertical), colocándolos uno debajo del otro, de arriba hacia abajo, según el orden en que están escritos en el HTML. Esto significa que el primer elemento aparecerá en la parte superior, el segundo justo debajo, y así sucesivamente, formando una pila vertical. Este comportamiento solo se aplica cuando el contenedor tiene la propiedad "display: flex", ya que esta activa el modelo de caja flexible. A diferencia del valor por defecto "row" (que alinea los elementos en una fila horizontal), "column" cambia completamente el eje principal, haciendo que la distribución de los elementos ocurra de forma vertical. Cabe destacar que "column" no altera el orden natural del HTML**, simplemente cambia la dirección en la que se acomodan los elementos visualmente. */
.elemento-con-flex-direction-column{
    display: flex;
    flex-direction: column;
}

/* &Column-reverse  
/* &El valor "column-reverse" en la propiedad "flex-direction" organiza los elementos hijos en una columna (vertical), pero en orden invertido, es decir, de abajo hacia arriba.  Esto significa que el primer elemento escrito en el HTML aparecerá visualmente en la parte inferior, el segundo un lugar más arriba, y así sucesivamente, invirtiendo el orden natural de los elementos. Este efecto solo se activa si el contenedor tiene la propiedad "display: flex", ya que es parte del modelo de caja flexible. A diferencia de "column", que los organiza de arriba a abajo, "column-reverse" invierte la dirección del eje principal, colocando los elementos desde el final hacia el inicio en una disposición vertical. Es importante señalar que esta propiedad solo afecta la forma en que los elementos se presentan visualmente**, pero **no modifica el orden real en el que están escritos en el HTML. */
.elemento-con-flex-direction-column-reverse{
    display: flex;
    flex-direction: column-reverse  ;
}

/* Todo - Envoltura del flex (flex-wrap): */